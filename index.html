<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>9x9 拼圖消消樂</title>
  <style>
    * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
    body{
      background:#1a1a1a; color:#fff; margin:0;
      height:100vh; height:100dvh;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      font-family: Arial, sans-serif;
      overflow:hidden;
    }

    .header{
      width:100%; max-width:720px;
      display:flex; justify-content:center; align-items:flex-end;
      position:relative; margin-bottom:10px; padding:0 10px;
    }
    #highScoreContainer{
      position:absolute; left:10px; bottom:5px;
      background:rgba(255,255,255,0.1);
      padding:5px 10px; border-radius:5px; border-left:4px solid #FFD700;
    }
    #scoreDisplay{
      font-size:clamp(40px, 10vw, 70px);
      font-weight:900;
      font-family:'Arial Black', sans-serif;
      user-select:none; -webkit-user-select:none;
    }
    #comboBadge{
      position:absolute; right:10px; bottom:5px;
      z-index: 50;
      color:white;
      background:rgba(255,255,255,0.10);
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.18);
      display:none;
      font-weight:900;
      letter-spacing:.5px;
      user-select:none; -webkit-user-select:none;
      pointer-events:none;
    }
    #comboBadge .label{ font-size:10px; color:#aaa; margin-right:6px; font-weight:700; }
    #comboBadge .value{ font-size:14px; }

    #gameWrapper{
      position:relative;
      width:95vw; max-width:860px;
      display:flex; justify-content:center;
    }
    canvas{
      background:#222;
      border-radius:12px;
      box-shadow:0 10px 40px rgba(0,0,0,0.5);
      width:100%; height:auto; display:block;
      touch-action:none;
    }
    #restartBtn{
      display:none;
      position:absolute; top:50%; left:50%;
      transform:translate(-50%, -50%);
      padding:15px 40px; font-size:20px; font-weight:900;
      color:#fff; border:none; border-radius:30px;
      cursor:pointer; z-index:100;
    }

    /* ========== Login / Menu Overlay ========== */
    #overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.78);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 20px;
    }
    .panel{
      width:min(580px, 95vw);
      background: rgba(25,25,25,0.98);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 18px;
      box-shadow: 0 20px 80px rgba(0,0,0,0.6);
      overflow: hidden;
    }
    .panelHead{
      padding: 16px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
    }
    .panelHead .title{
      font-weight: 900;
      letter-spacing: .5px;
      font-size: 16px;
    }
    .panelBody{
      padding: 16px 18px 18px;
    }

    .tabs{
      display:flex; gap:10px;
      margin-bottom: 14px;
    }
    .tabBtn{
      flex:1;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.10);
      color:#fff;
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 800;
    }
    .tabBtn.active{
      background: rgba(255,255,255,0.14);
      border-color: rgba(255,255,255,0.20);
      box-shadow: 0 0 18px rgba(255,255,255,0.08);
    }

    .row{
      display:flex;
      gap:10px;
      margin: 10px 0;
      align-items:center;
    }
    .label2{
      width: 86px;
      color: rgba(255,255,255,0.70);
      font-weight: 700;
      font-size: 13px;
    }
    input[type="text"]{
      flex:1;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      color:#fff;
      padding: 10px 12px;
      border-radius: 12px;
      outline: none;
      font-size: 14px;
      font-weight: 800;
    }
    input[type="text"]::placeholder{ color: rgba(255,255,255,0.35); }

    .actions{
      display:flex; gap:10px;
      margin-top: 14px;
    }
    .btn{
      flex:1;
      border:none;
      border-radius: 14px;
      padding: 12px 14px;
      font-weight: 900;
      cursor:pointer;
      color:#111;
    }
    .btnPrimary{
      background: #FFD700;
    }
    .btnGhost{
      background: rgba(255,255,255,0.10);
      color:#fff;
      border: 1px solid rgba(255,255,255,0.12);
    }
    .hint{
      margin-top: 10px;
      color: rgba(255,255,255,0.55);
      font-size: 12px;
      line-height: 1.5;
    }

    .board{
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      overflow: hidden;
      background: rgba(255,255,255,0.04);
    }
    .boardHeader, .boardRow{
      display:grid;
      grid-template-columns: 56px 1fr 110px;
      gap: 10px;
      padding: 10px 12px;
      align-items:center;
    }
    .boardHeader{
      background: rgba(255,255,255,0.06);
      font-size: 12px;
      color: rgba(255,255,255,0.70);
      font-weight: 900;
      letter-spacing: .4px;
    }
    .boardRow{
      border-top: 1px solid rgba(255,255,255,0.06);
      font-size: 14px;
      font-weight: 800;
    }
    .rankPill{
      width: 38px; height: 26px;
      border-radius: 999px;
      display:flex; align-items:center; justify-content:center;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.10);
      font-size: 12px;
      font-weight: 900;
      color: rgba(255,255,255,0.88);
    }
    .muted{
      color: rgba(255,255,255,0.60);
      font-weight: 800;
    }
    .right{
      text-align:right;
    }
    .meRow{
      background: rgba(255,215,0,0.10);
      border-top: 1px solid rgba(255,215,0,0.22);
    }
    .sep{
      height: 1px;
      background: rgba(255,255,255,0.10);
      margin: 10px 0;
    }
    .smallNote{
      font-size: 12px;
      color: rgba(255,255,255,0.60);
      margin-top: 10px;
      line-height: 1.5;
    }
  </style>
</head>
<body>

  <div class="header">
    <div id="highScoreContainer">
      <div style="font-size:10px;color:#aaa;">個人最高分</div>
      <div id="highScore">0</div>
    </div>

    <div id="scoreDisplay">0</div>

    <div id="comboBadge">
      <span class="label">COMBO</span>
      <span class="value" id="comboCount">x0</span>
    </div>
  </div>

  <div id="gameWrapper">
    <canvas id="gameCanvas"></canvas>
    <button id="restartBtn">PLAY AGAIN</button>
  </div>

  <!-- Overlay: Login / Leaderboard -->
  <div id="overlay">
    <div class="panel">
      <div class="panelHead">
        <div class="title">9x9 拼圖消消樂</div>
        <div id="playerMini" class="muted"></div>
      </div>

      <div class="panelBody">
        <div class="tabs">
          <button id="tabLogin" class="tabBtn active">登入 / 取名</button>
          <button id="tabBoard" class="tabBtn">排行榜</button>
        </div>

        <div id="viewLogin">
          <div class="row">
            <div class="label2">玩家名字</div>
            <input id="nameInput" type="text" maxlength="16" placeholder="輸入暱稱（最多 16 字）" />
          </div>

          <div class="actions">
            <button id="btnStart" class="btn btnPrimary">開始遊戲</button>
            <button id="btnToBoard" class="btn btnGhost">看排行榜</button>
          </div>

          <div class="hint">
            - 排行榜是「全球榜」，會看到網路上其他玩家分數。<br/>
            - 左上角是你自己裝置的最高分。
          </div>
        </div>

        <div id="viewBoard" style="display:none;">
          <div class="actions" style="margin-top:0;">
            <button id="btnBackToLogin" class="btn btnGhost">回到首頁</button>
            <button id="btnRefreshBoard" class="btn btnGhost">刷新</button>
            <button id="btnPlayAgain" class="btn btnPrimary">再玩一局</button>
          </div>

          <div class="board" style="margin-top:12px;">
            <div class="boardHeader">
              <div>RANK</div>
              <div>NAME</div>
              <div class="right">SCORE</div>
            </div>
            <div id="boardList"></div>
          </div>

          <div class="smallNote" id="boardStatus"></div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
  /* =========================================================
   *  Firebase（Firestore 全球榜）
   * ========================================================= */
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import {
    getFirestore, doc, setDoc, getDoc, collection,
    query, orderBy, limit, getDocs, serverTimestamp,
    where, getCountFromServer
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDgLjm7EvbkziBiatT0UN-OMyGp9WVzbdQ",
    authDomain: "game-cancelblock.firebaseapp.com",
    projectId: "game-cancelblock",
    storageBucket: "game-cancelblock.firebasestorage.app",
    messagingSenderId: "734625700314",
    appId: "1:734625700314:web:b65e6505a37f9fa226c8e3",
    measurementId: "G-E3N6NP4J9K"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const LEADERBOARD_COL = "leaderboard_v1";

  // 每台裝置固定一個 uid（避免同名互相覆蓋）
  const LS_UID_KEY = "blockDeviceUidV1";
  function getOrCreateDeviceUid() {
    let uid = localStorage.getItem(LS_UID_KEY);
    if (!uid) {
      uid = (crypto?.randomUUID?.() || ("uid_" + Math.random().toString(16).slice(2) + Date.now()));
      localStorage.setItem(LS_UID_KEY, uid);
    }
    return uid;
  }
  const deviceUid = getOrCreateDeviceUid();

  async function remoteUpsertBest(name, score) {
    name = (name || "").trim().slice(0, 16);
    if (!name) return;

    const ref = doc(db, LEADERBOARD_COL, deviceUid);
    console.log("[LB] writing to", LEADERBOARD_COL, deviceUid, { name, score });
    const snap = await getDoc(ref);
    const prev = snap.exists() ? Number(snap.data().score || 0) : 0;

    if (score > prev) {
      await setDoc(ref, { uid: deviceUid, name, score, updatedAt: serverTimestamp() }, { merge: true });
    } else {
      await setDoc(ref, { uid: deviceUid, name, updatedAt: serverTimestamp() }, { merge: true });
    }
  }

  async function remoteFetchTop(topN = 10) {
    const q = query(collection(db, LEADERBOARD_COL), orderBy("score", "desc"), limit(topN));
    const snap = await getDocs(q);
    return snap.docs.map(d => d.data());
  }

  async function remoteFetchMe() {
    const ref = doc(db, LEADERBOARD_COL, deviceUid);
    const snap = await getDoc(ref);
    return snap.exists() ? snap.data() : null;
  }

  async function remoteComputeMyRank(myScore) {
    if (typeof myScore !== "number") return null;
    const col = collection(db, LEADERBOARD_COL);
    const q = query(col, where("score", ">", myScore));
    const agg = await getCountFromServer(q);
    const higher = agg.data().count || 0;
    return higher + 1;
  }

  /* =========================================================
   *  Overlay UI
   * ========================================================= */
  const LS_NAME_KEY = "blockPlayerName";
  function getPlayerName() { return (localStorage.getItem(LS_NAME_KEY) || "").trim(); }
  function setPlayerName(name) { localStorage.setItem(LS_NAME_KEY, name.trim()); }

  const overlay = document.getElementById("overlay");
  const tabLogin = document.getElementById("tabLogin");
  const tabBoard = document.getElementById("tabBoard");
  const viewLogin = document.getElementById("viewLogin");
  const viewBoard = document.getElementById("viewBoard");
  const nameInput = document.getElementById("nameInput");
  const btnStart = document.getElementById("btnStart");
  const btnToBoard = document.getElementById("btnToBoard");
  const btnBackToLogin = document.getElementById("btnBackToLogin");
  const btnRefreshBoard = document.getElementById("btnRefreshBoard");
  const btnPlayAgain = document.getElementById("btnPlayAgain");
  const playerMini = document.getElementById("playerMini");
  const boardList = document.getElementById("boardList");
  const boardStatus = document.getElementById("boardStatus");

  function showOverlay() { overlay.style.display = "flex"; }
  function hideOverlay() { overlay.style.display = "none"; }
  function syncPlayerMini() {
    const n = getPlayerName();
    playerMini.textContent = n ? `玩家：${n}` : "";
  }

  function switchTab(which) {
    const isLogin = which === "login";
    tabLogin.classList.toggle("active", isLogin);
    tabBoard.classList.toggle("active", !isLogin);
    viewLogin.style.display = isLogin ? "block" : "none";
    viewBoard.style.display = isLogin ? "none" : "block";
    if (!isLogin) refreshBoardUI();
  }

  tabLogin.onclick = () => switchTab("login");
  tabBoard.onclick = () => switchTab("board");
  btnToBoard.onclick = () => switchTab("board");

  btnBackToLogin.onclick = () => {
    showOverlay();
    switchTab("login");
    nameInput.focus();
  };

  btnRefreshBoard.onclick = () => refreshBoardUI();

  btnPlayAgain.onclick = () => {
    hideOverlay();
    gameOver = false;
    resetGame();
  };

  btnStart.onclick = () => {
    const name = nameInput.value.trim();
    if (!name) {
      nameInput.focus();
      nameInput.placeholder = "請先輸入暱稱！";
      return;
    }
    setPlayerName(name);
    syncPlayerMini();
    hideOverlay();
    resetGame();
  };
  nameInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") btnStart.click();
  });

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"
    }[m]));
  }

  function renderRow(rank, name, score, isMe=false) {
    let pillBg = "rgba(255,255,255,0.10)";
    let pillBd = "rgba(255,255,255,0.10)";
    if (rank === 1) { pillBg = "rgba(255,215,0,0.22)"; pillBd = "rgba(255,215,0,0.35)"; }
    else if (rank === 2) { pillBg = "rgba(200,200,200,0.18)"; pillBd = "rgba(200,200,200,0.28)"; }
    else if (rank === 3) { pillBg = "rgba(205,127,50,0.18)"; pillBd = "rgba(205,127,50,0.28)"; }

    const div = document.createElement("div");
    div.className = "boardRow" + (isMe ? " meRow" : "");
    div.innerHTML = `
      <div class="rankPill" style="background:${pillBg};border-color:${pillBd}">${rank}</div>
      <div>${escapeHtml(name || "-")}${isMe ? ' <span class="muted">(你)</span>' : ""}</div>
      <div class="right">${Number(score||0).toLocaleString()}</div>
    `;
    return div;
  }

  async function refreshBoardUI() {
    boardStatus.textContent = "讀取中...";
    boardList.innerHTML = "";

    try {
      const top = await remoteFetchTop(10);

      if (!top.length) {
        const empty = document.createElement("div");
        empty.className = "boardRow";
        empty.innerHTML = `
          <div class="rankPill">-</div>
          <div class="muted">目前沒有紀錄</div>
          <div class="right muted">-</div>
        `;
        boardList.appendChild(empty);
        boardStatus.textContent = "目前榜單為空。先玩一局產生資料～";
        return;
      }

      top.forEach((item, i) => {
        const isMe = (item.uid === deviceUid);
        boardList.appendChild(renderRow(i+1, item.name, item.score, isMe));
      });

      const me = await remoteFetchMe();
      if (me && typeof me.score === "number") {
        const inTop = top.some(x => x.uid === deviceUid);
        if (!inTop) {
          const sep = document.createElement("div");
          sep.className = "sep";
          boardList.appendChild(sep);

          const myRank = await remoteComputeMyRank(me.score);
          if (myRank != null) {
            boardList.appendChild(renderRow(myRank, me.name, me.score, true));
          }
        }
      }

      boardStatus.textContent = "已更新（全球排行）。";
    } catch (e) {
      console.error("Leaderboard error:", e);
      boardStatus.textContent = "排行榜讀取失敗。請開 Console 看錯誤訊息。";
      const err = document.createElement("div");
      err.className = "boardRow";
      err.innerHTML = `
        <div class="rankPill">!</div>
        <div class="muted">無法載入全球榜</div>
        <div class="right muted">-</div>
      `;
      boardList.appendChild(err);
    }
  }

  /* =========================================================
   *  遊戲本體（吸附/回彈/紅色提示/特效/Combo）
   * ========================================================= */
  const GRID_SIZE = 9;
  const CELL_SIZE = 55;

  const SIDEBAR_W = 250;
  const BOTTOMBAR_H = 220;

  const DRAG_GAIN = 1.6;
  const MAGNET_SEARCH_RADIUS = 2;

  const PREVIEW_ALPHA_OK = 0.28;
  const PREVIEW_ALPHA_BAD = 0.14;

  const DRAG_LIFT = CELL_SIZE * 0.9;

  const FAIL_SHAKE = 14;
  const FAIL_VIBRATION_PATTERN = [25, 30, 25];

  let failOverlayLife = 0;

  let bounceLife = 0;
  let bounceFromX = 0, bounceFromY = 0;
  let bounceToX = 0, bounceToY = 0;
  let bounceShape = null;
  let bounceTheme = null;

  let particles = [];
  let lineFlashes = [];

  // === Clear animation state ===
  // grid cell: 0 empty, 1 filled, 2 clearing (fade-out)
  let clearingCells = [];                 // array of {r,c,life}
  let clearingMap = new Map();            // key "r,c" -> {life}

  let dragStartPX = 0, dragStartPY = 0;
  let dragStartAX = 0, dragStartAY = 0;
  let dragNowAX = 0, dragNowAY = 0;

  function isMobileLayout() { return window.matchMedia("(max-width: 600px)").matches; }

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  const restartBtn = document.getElementById('restartBtn');

  const comboBadge = document.getElementById('comboBadge');
  const comboCountEl = document.getElementById('comboCount');

  const THEMES = [
    { main:'#4A90E2', dark:'#21508A', light:'#A4C8F5' },
    { main:'#50E3C2', dark:'#2A8F79', light:'#B2F2E5' },
    { main:'#F5A623', dark:'#A36B0D', light:'#FCD9A1' }
  ];

  const SHAPE_DEFS = [
    { shape: [[0,0],[0,1]], weight: 10 },
    { shape: [[0,0],[1,0]], weight: 10 },
    { shape: [[0,0],[0,1],[1,0],[1,1]], weight: 10 },
    { shape: [[0,0],[0,1],[0,2]], weight: 10 },
    { shape: [[0,0],[1,0],[2,0]], weight: 10 },
    { shape: [[0,0],[1,0],[1,1]], weight: 10 },
    { shape: [[0,0]], weight: 10 },
    { shape: [[0,0],[0,1],[0,2],[0,3]], weight: 10 },
    { shape: [[0,0],[1,0],[2,0],[3,0]], weight: 10 },
    { shape: [[0,0],[1,0],[1,1],[2,1]], weight: 10 },
    { shape: [[0,1],[0,2],[1,0],[1,1]], weight: 10 },
    { shape: [[0,1],[1,0],[1,1],[1,2]], weight: 10 },
    { shape: [[0,0],[1,0],[2,0],[2,1]], weight: 10 },
    { shape: [[0,0],[0,1],[0,2],[1,0],[2,0]], weight: 3 },
    { shape: [[0,1],[1,0],[1,1],[1,2],[2,1]], weight: 3 },
    { shape: [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]], weight: 3 }
  ];

  let currentTheme;
  let grid, hand, score, highScore;

  let draggingIdx = null;
  let pointerX = 0, pointerY = 0;
  let gameOver = false;

  let shakeIntensity = 0;
  let currentComboCount = 0;

  let floatingTexts = [];
  let layout = null;

  function getComboTier(combo) {
    if (combo >= 6) return { name:"GODLIKE", color:"#FFEA00", glow:"rgba(255,234,0,0.75)", border:"rgba(255,234,0,0.55)" };
    if (combo >= 4) return { name:"PERFECT", color:"#FFD700", glow:"rgba(255,215,0,0.65)", border:"rgba(255,215,0,0.45)" };
    if (combo >= 3) return { name:"GREAT",   color:"#7CFCFF", glow:"rgba(124,252,255,0.55)", border:"rgba(124,252,255,0.40)" };
    if (combo >= 2) return { name:"NICE",    color:"#B7FF6A", glow:"rgba(183,255,106,0.45)", border:"rgba(183,255,106,0.35)" };
    return             { name:"GOOD",    color:"#FFFFFF", glow:"rgba(255,255,255,0.30)", border:"rgba(255,255,255,0.20)" };
  }

  // ✅ COMBO UI 常駐，無 combo 顯示 x0
  function updateComboUI() {
    comboBadge.style.display = "inline-flex";
    comboBadge.style.alignItems = "center";

    const shown = Math.max(0, currentComboCount);
    comboCountEl.innerText = "x" + shown;

    const tier = getComboTier(1);
    if (currentComboCount > 0) {
      const t2 = getComboTier(currentComboCount);
      comboBadge.style.borderColor = t2.border;
      comboBadge.style.boxShadow = `0 0 18px ${t2.glow}`;
      comboBadge.style.opacity = "1";
    } else {
      comboBadge.style.borderColor = "rgba(255,255,255,0.18)";
      comboBadge.style.boxShadow = "none";
      comboBadge.style.opacity = "0.55";
    }
  }

  function computeLayout() {
    const mobile = isMobileLayout();
    if (mobile) {
      const rawW = GRID_SIZE * CELL_SIZE;
      const rawH = GRID_SIZE * CELL_SIZE + BOTTOMBAR_H;

      const handX = 0;
      const handY = GRID_SIZE * CELL_SIZE;
      const handW = rawW;
      const handH = BOTTOMBAR_H;

      const padX = 20;
      const padY = 25;
      const slotW = (handW - padX * 2) / 3;
      const slotH = handH - padY * 2;

      const slots = [0,1,2].map(i => ({
        x: handX + padX + i * slotW,
        y: handY + padY,
        w: slotW,
        h: slotH
      }));

      return {
        mode: "mobile",
        rawW, rawH,
        gridX: 0, gridY: 0,
        hand: { x: handX, y: handY, w: handW, h: handH, slots },
        handBlock: 24,
        handGap: 4
      };
    } else {
      const rawW = GRID_SIZE * CELL_SIZE + SIDEBAR_W;
      const rawH = GRID_SIZE * CELL_SIZE;

      const handX = GRID_SIZE * CELL_SIZE;
      const handY = 0;
      const handW = SIDEBAR_W;
      const handH = rawH;

      const slots = [0,1,2].map(i => ({
        x: handX + 20,
        y: 40 + i * 150,
        w: handW - 40,
        h: 120
      }));

      return {
        mode: "desktop",
        rawW, rawH,
        gridX: 0, gridY: 0,
        hand: { x: handX, y: handY, w: handW, h: handH, slots },
        handBlock: 20,
        handGap: 2
      };
    }
  }

  function applyLayout(newLayout) {
    layout = newLayout;
    canvas.width = layout.rawW;
    canvas.height = layout.rawH;
  }

  function pathRoundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function drawBlock(x, y, size, r, theme, alpha = 1.0) {
    ctx.save();
    ctx.globalAlpha = alpha;
    pathRoundedRect(x, y, size, size, r);
    const g = ctx.createLinearGradient(x, y, x + size, y + size);
    g.addColorStop(0, theme.light);
    g.addColorStop(1, theme.dark);
    ctx.fillStyle = g;
    ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,0.2)";
    ctx.beginPath();
    ctx.arc(x + size*0.3, y + size*0.3, size*0.15, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawTextWithStroke(txt, x, y, size, color, stroke = "rgba(0,0,0,0.55)", align = "center") {
    ctx.save();
    ctx.font = `900 ${size}px Arial`;
    ctx.textAlign = align;
    ctx.textBaseline = "middle";
    ctx.lineWidth = Math.max(3, size * 0.12);
    ctx.strokeStyle = stroke;
    ctx.fillStyle = color;
    ctx.strokeText(txt, x, y);
    ctx.fillText(txt, x, y);
    ctx.restore();
  }

  function resetGame() {
    applyLayout(computeLayout());

    currentTheme = THEMES[Math.floor(Math.random() * THEMES.length)];

    grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
    score = 0;
    highScore = Number(localStorage.getItem('blockHighScore') || 0);

    gameOver = false;
    shakeIntensity = 0;
    currentComboCount = 0;
    floatingTexts = [];
    particles = [];
    lineFlashes = [];
    failOverlayLife = 0;
    bounceLife = 0;

    // clear-anim state
    clearingCells = [];
    clearingMap.clear();

    document.getElementById('scoreDisplay').innerText = "0";
    document.getElementById('highScore').innerText = String(highScore);
    restartBtn.style.display = "none";

    updateComboUI();
    refreshHand();
  }

  function refreshHand() {
    hand = [];
    for (let i = 0; i < 3; i++) {
      const totalW = SHAPE_DEFS.reduce((s, x) => s + x.weight, 0);
      let rand = Math.random() * totalW;
      let chosen = SHAPE_DEFS[0].shape;
      for (const def of SHAPE_DEFS) {
        if (rand < def.weight) { chosen = def.shape; break; }
        rand -= def.weight;
      }
      hand.push(chosen);
    }
  }

  // ✅ clearing(2) 也視為佔用，避免放置/判定穿模
  function canPlace(shape, r, c) {
    if (!shape || r < 0 || c < 0) return false;
    for (let i = 0; i < shape.length; i++) {
      const nr = r + shape[i][0];
      const nc = c + shape[i][1];
      if (nr >= GRID_SIZE || nc >= GRID_SIZE || grid[nr][nc] !== 0) return false;
    }
    return true;
  }

  function spawnClearParticles(cells) {
    for (const {r, c} of cells) {
      const cx = layout.gridX + c * CELL_SIZE + CELL_SIZE / 2;
      const cy = layout.gridY + r * CELL_SIZE + CELL_SIZE / 2;

      const n = 10 + Math.floor(Math.random() * 6);
      for (let i = 0; i < n; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = 2 + Math.random() * 6;
        particles.push({
          x: cx, y: cy,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd - 1.5,
          life: 1,
          size: 2 + Math.random() * 3
        });
      }
    }
  }

  function updateAndDrawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.life -= 0.03;
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.2;
      p.vx *= 0.98;
      p.vy *= 0.98;

      if (p.life <= 0) { particles.splice(i, 1); continue; }

      ctx.save();
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = "rgba(255, 215, 0, 1)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.beginPath();
      ctx.arc(p.x - 1, p.y - 1, p.size * 0.55, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function spawnLineFlash(rows, cols) {
    for (const r of rows) lineFlashes.push({ type:'row', idx:r, life:1 });
    for (const c of cols) lineFlashes.push({ type:'col', idx:c, life:1 });
  }

  function updateAndDrawLineFlashes() {
    for (let i = lineFlashes.length - 1; i >= 0; i--) {
      const f = lineFlashes[i];
      f.life -= 0.06;
      if (f.life <= 0) { lineFlashes.splice(i, 1); continue; }

      ctx.save();
      ctx.globalAlpha = Math.max(0, f.life);
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      if (f.type === 'row') {
        const y = layout.gridY + f.idx * CELL_SIZE;
        ctx.fillRect(layout.gridX, y, GRID_SIZE * CELL_SIZE, CELL_SIZE);
      } else {
        const x = layout.gridX + f.idx * CELL_SIZE;
        ctx.fillRect(x, layout.gridY, CELL_SIZE, GRID_SIZE * CELL_SIZE);
      }
      ctx.restore();
    }
  }

  function pushFloatingBreakdown(x, y, tier, base, multi, comboBonus, gain) {
    const lines = [];
    lines.push({ txt: tier.name, color: tier.color, sizeMul: 1.25 });
    lines.push({ txt: `+${gain} TOTAL`, color: "#FFD700", sizeMul: 1.05 });
    lines.push({ txt: `+${base} Base`, color: "rgba(255,255,255,0.95)", sizeMul: 0.85 });
    if (multi > 0) lines.push({ txt: `+${multi} Multi`, color: "rgba(124,252,255,0.95)", sizeMul: 0.85 });
    lines.push({ txt: `+${comboBonus} Combo`, color: "rgba(183,255,106,0.95)", sizeMul: 0.85 });

    floatingTexts.push({
      lines,
      x, y,
      life: 1,
      vy: 1.25,
      size: 28,
      align: "center",
      stroke: "rgba(0,0,0,0.65)"
    });
  }

  function updateAndDrawFloatingTexts() {
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      const t = floatingTexts[i];
      t.y -= t.vy;
      t.life -= 0.02;

      const alpha = Math.max(0, t.life);
      if (alpha <= 0) { floatingTexts.splice(i, 1); continue; }

      let y = t.y;
      for (let j = 0; j < t.lines.length; j++) {
        const line = t.lines[j];
        const sz = t.size * (line.sizeMul ?? 1);
        ctx.save();
        ctx.globalAlpha = alpha;
        drawTextWithStroke(line.txt, t.x, y, sz, line.color, t.stroke, t.align);
        ctx.restore();
        y += sz * 1.05;
      }
    }
  }

  function calcGain(lines, comboCount) {
    const base = lines * GRID_SIZE;
    const multiLineBonus = Math.max(0, lines - 1) * 16;
    const comboBonus = 25 + (comboCount - 1) * 20;
    const gain = base + multiLineBonus + comboBonus;
    return { base, multiLineBonus, comboBonus, gain };
  }

  function startClearingCells(clearedCells) {
    for (const { r, c } of clearedCells) {
      if (grid[r][c] === 1) {
        grid[r][c] = 2; // clearing
        const key = `${r},${c}`;
        if (!clearingMap.has(key)) {
          const obj = { r, c, life: 1 };
          clearingCells.push(obj);
          clearingMap.set(key, obj);
        } else {
          // 若重複觸發，刷新生命
          clearingMap.get(key).life = 1;
        }
      }
    }
  }

  function updateClearingCells() {
    for (let i = clearingCells.length - 1; i >= 0; i--) {
      const cc = clearingCells[i];
      cc.life -= 0.08; // 淡出速度
      if (cc.life <= 0) {
        if (grid[cc.r][cc.c] === 2) grid[cc.r][cc.c] = 0;
        clearingMap.delete(`${cc.r},${cc.c}`);
        clearingCells.splice(i, 1);
      }
    }
  }

  function checkAndClear() {
    const rs = [], cs = [];

    // ✅ 1 或 2 都視為滿格（clearing 還沒真正變空前）
    for (let r = 0; r < GRID_SIZE; r++) if (grid[r].every(v => v !== 0)) rs.push(r);

    for (let c = 0; c < GRID_SIZE; c++) {
      let full = true;
      for (let r = 0; r < GRID_SIZE; r++) if (grid[r][c] === 0) full = false;
      if (full) cs.push(c);
    }

    const lines = rs.length + cs.length;
    if (lines <= 0) return false;

    currentComboCount++;
    updateComboUI();

    const { base, multiLineBonus, comboBonus, gain } = calcGain(lines, currentComboCount);
    score += gain;
    document.getElementById('scoreDisplay').innerText = String(score);

    if (score > highScore) {
      highScore = score;
      localStorage.setItem('blockHighScore', String(score));
      document.getElementById('highScore').innerText = String(score);
    }

    const clearedSet = new Set();
    for (const r of rs) for (let c = 0; c < GRID_SIZE; c++) clearedSet.add(`${r},${c}`);
    for (const c of cs) for (let r = 0; r < GRID_SIZE; r++) clearedSet.add(`${r},${c}`);
    const clearedCells = Array.from(clearedSet).map(s => {
      const [r, c] = s.split(',').map(Number);
      return { r, c };
    });

    // ✅ 特效：閃線 + 粒子 + 震動 + 浮字
    spawnLineFlash(rs, cs);
    spawnClearParticles(clearedCells);
    shakeIntensity = Math.max(shakeIntensity, lines * 8);

    const tier = getComboTier(currentComboCount);
    pushFloatingBreakdown(
      layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
      layout.gridY + (GRID_SIZE * CELL_SIZE) / 2 - 60,
      tier, base, multiLineBonus, comboBonus, gain
    );

    // ✅ 不要立刻清 0，先進入 clearing 狀態做淡出
    startClearingCells(clearedCells);

    return true;
  }

  function getCanvasPosFromClient(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / (rect.width || 1));
    const y = (clientY - rect.top) * (canvas.height / (rect.height || 1));
    return { x, y };
  }

  function pickHandIndex(pos) {
    const { slots } = layout.hand;
    for (let i = 0; i < slots.length; i++) {
      const s = slots[i];
      if (pos.x >= s.x && pos.x <= s.x + s.w && pos.y >= s.y && pos.y <= s.y + s.h) {
        if (hand[i]) return i;
      }
    }
    return null;
  }

  function shapeBoundingBox(shape) {
    let minR = Infinity, minC = Infinity, maxR = -Infinity, maxC = -Infinity;
    for (const [r,c] of shape) {
      minR = Math.min(minR, r); minC = Math.min(minC, c);
      maxR = Math.max(maxR, r); maxC = Math.max(maxC, c);
    }
    return { minR, minC, maxR, maxC, w: maxC - minC + 1, h: maxR - minR + 1 };
  }

  function getHandSlotHomeAnchor(idx, shape) {
    const slot = layout.hand.slots[idx];
    const bb = shapeBoundingBox(shape);
    const block = layout.handBlock;
    const gap = layout.handGap;

    const shapeW = bb.w * (block + gap) - gap;
    const shapeH = bb.h * (block + gap) - gap;

    const startX = slot.x + (slot.w - shapeW) / 2;
    const startY = slot.y + (slot.h - shapeH) / 2;

    const anchorCenterX = startX + (0 - bb.minC) * (block + gap) + block / 2;
    const anchorCenterY = startY + (0 - bb.minR) * (block + gap) + block / 2;

    return { x: anchorCenterX - CELL_SIZE * 0.5, y: anchorCenterY - CELL_SIZE * 0.5 };
  }

  function findBestMagnet(shape, anchorX, anchorY) {
    const gx = (anchorX - layout.gridX) / CELL_SIZE;
    const gy = (anchorY - layout.gridY) / CELL_SIZE;

    const baseC = Math.round(gx);
    const baseR = Math.round(gy);

    let best = null;

    for (let dr = -MAGNET_SEARCH_RADIUS; dr <= MAGNET_SEARCH_RADIUS; dr++) {
      for (let dc = -MAGNET_SEARCH_RADIUS; dc <= MAGNET_SEARCH_RADIUS; dc++) {
        const r = baseR + dr;
        const c = baseC + dc;
        if (r < 0 || c < 0 || r >= GRID_SIZE || c >= GRID_SIZE) continue;
        if (!canPlace(shape, r, c)) continue;

        const snappedX = layout.gridX + c * CELL_SIZE;
        const snappedY = layout.gridY + r * CELL_SIZE;

        const dx = (anchorX - snappedX) / CELL_SIZE;
        const dy = (anchorY - snappedY) / CELL_SIZE;
        const distNorm = Math.hypot(dx, dy);

        if (best === null || distNorm < best.distNorm) best = { r, c, snappedX, snappedY, distNorm };
      }
    }

    if (!best) return { can:false };
    return { ...best, can:true };
  }

  function failFeedback() {
    shakeIntensity = Math.max(shakeIntensity, FAIL_SHAKE);
    failOverlayLife = 1;

    floatingTexts.push({
      lines: [{ txt: "放不下！", color: "#FF6A6A", sizeMul: 1.1 }],
      x: layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
      y: layout.gridY + (GRID_SIZE * CELL_SIZE) / 2 - 30,
      life: 1,
      vy: 1.1,
      size: 28,
      align: "center",
      stroke: "rgba(0,0,0,0.70)"
    });

    if (navigator.vibrate) {
      try { navigator.vibrate(FAIL_VIBRATION_PATTERN); } catch (_) {}
    }
  }

  function startBounceBack(idx, shape, fromAnchorX, fromAnchorY) {
    bounceLife = 1;
    bounceShape = shape;
    bounceTheme = currentTheme;

    bounceFromX = fromAnchorX;
    bounceFromY = fromAnchorY;

    const home = getHandSlotHomeAnchor(idx, shape);
    bounceToX = home.x;
    bounceToY = home.y;
  }

  // GAME OVER：跳排行榜 + 顯示「再玩一局 / 回到首頁」
  async function onGameOver() {
    const name = getPlayerName();
    if (name) {
      try {
        await remoteUpsertBest(name, score);
        console.log("[LB] upsert ok:", { name, score, deviceUid });
      } catch (e) {
        console.error("[LB] upsert FAILED:", e);
        boardStatus.textContent = "⚠️ 上傳分數失敗（請開 Console 看錯誤）";
      }
    }
    switchTab("board");
    showOverlay();
  }

  function handlePointerDown(e) {
    if (gameOver) return;
    canvas.setPointerCapture?.(e.pointerId);

    const pos = getCanvasPosFromClient(e.clientX, e.clientY);
    pointerX = pos.x; pointerY = pos.y;

    const idx = pickHandIndex(pos);
    if (idx !== null) {
      draggingIdx = idx;

      dragStartPX = pointerX;
      dragStartPY = pointerY;

      const home = getHandSlotHomeAnchor(draggingIdx, hand[draggingIdx]);
      dragStartAX = home.x;
      dragStartAY = home.y;

      dragNowAX = dragStartAX;
      dragNowAY = dragStartAY;
    }
  }

  function handlePointerMove(e) {
    const events = (e.getCoalescedEvents && e.getCoalescedEvents()) || null;
    const last = events && events.length ? events[events.length - 1] : e;

    const pos = getCanvasPosFromClient(last.clientX, last.clientY);
    pointerX = pos.x; pointerY = pos.y;

    if (draggingIdx !== null) {
      const dx = (pointerX - dragStartPX) * DRAG_GAIN;
      const dy = (pointerY - dragStartPY) * DRAG_GAIN;
      dragNowAX = dragStartAX + dx;
      dragNowAY = dragStartAY + dy;
    }
  }

  function handlePointerUpOrCancel() {
    if (draggingIdx === null) return;

    const shape = hand[draggingIdx];
    if (shape) {
      const anchorX = dragNowAX;
      const anchorY = dragNowAY;

      const best = findBestMagnet(shape, anchorX, anchorY);

      let r, c;
      if (best.can) { r = best.r; c = best.c; }
      else {
        r = Math.floor((anchorY - layout.gridY) / CELL_SIZE);
        c = Math.floor((anchorX - layout.gridX) / CELL_SIZE);
      }

      r = Math.max(0, Math.min(GRID_SIZE - 1, r));
      c = Math.max(0, Math.min(GRID_SIZE - 1, c));

      if (canPlace(shape, r, c)) {
        for (const coord of shape) grid[r + coord[0]][c + coord[1]] = 1;
        hand[draggingIdx] = null;

        // combo：放置成功但沒消 -> 清 combo；放置失敗不清
        const cleared = checkAndClear();
        if (!cleared) { currentComboCount = 0; updateComboUI(); }

        if (hand.every(h => h === null)) refreshHand();

        let dead = true;
        for (const s of hand) {
          if (!s) continue;
          for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
              if (canPlace(s, i, j)) { dead = false; break; }
            }
            if (!dead) break;
          }
          if (!dead) break;
        }
        if (dead) { gameOver = true; onGameOver(); }
      } else {
        failFeedback();
        startBounceBack(draggingIdx, shape, anchorX, anchorY);
      }
    }

    draggingIdx = null;
  }

  canvas.addEventListener('pointerdown', handlePointerDown);
  window.addEventListener('pointermove', handlePointerMove);
  window.addEventListener('pointerup', handlePointerUpOrCancel);
  window.addEventListener('pointercancel', handlePointerUpOrCancel);
  window.addEventListener('pointerrawupdate', handlePointerMove);

  function drawHand() {
    const { slots } = layout.hand;

    if (layout.mode === "mobile") {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(layout.hand.x, layout.hand.y, layout.hand.w, layout.hand.h);
      ctx.restore();
    }

    for (let i = 0; i < 3; i++) {
      const shape = hand[i];
      const slot = slots[i];

      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 2;
      pathRoundedRect(slot.x + 6, slot.y + 6, slot.w - 12, slot.h - 12, 14);
      ctx.stroke();
      ctx.restore();

      if (!shape || i === draggingIdx) continue;

      const bb = shapeBoundingBox(shape);
      const block = layout.handBlock;
      const gap = layout.handGap;

      const shapeW = bb.w * (block + gap) - gap;
      const shapeH = bb.h * (block + gap) - gap;

      const startX = slot.x + (slot.w - shapeW) / 2;
      const startY = slot.y + (slot.h - shapeH) / 2;

      for (const coord of shape) {
        const x = startX + (coord[1] - bb.minC) * (block + gap);
        const y = startY + (coord[0] - bb.minR) * (block + gap);
        drawBlock(x, y, block, 6, currentTheme, 1);
      }
    }
  }

  function updateAndDrawBounce() {
    if (bounceLife <= 0 || !bounceShape || !bounceTheme) return;

    const t = 1 - bounceLife;
    const c1 = 1.70158;
    const c3 = c1 + 1;
    const easeOutBack = (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
    const k = easeOutBack(Math.min(1, Math.max(0, t)));

    const ax = bounceFromX + (bounceToX - bounceFromX) * k;
    const ay = bounceFromY + (bounceToY - bounceFromY) * k;

    const scale = 0.96 + 0.06 * (1 - Math.abs(0.5 - t) * 2);

    ctx.save();
    ctx.globalAlpha = 0.9 * bounceLife;

    for (const coord of bounceShape) {
      const x = ax + coord[1] * CELL_SIZE;
      const y = (ay - DRAG_LIFT * 0.45) + coord[0] * CELL_SIZE;
      const sx = x + (CELL_SIZE - 4) * (1 - scale) * 0.5;
      const sy = y + (CELL_SIZE - 4) * (1 - scale) * 0.5;
      drawBlock(sx, sy, (CELL_SIZE - 4) * scale, 8, bounceTheme, ctx.globalAlpha);
    }

    ctx.restore();

    bounceLife -= 0.06;
    if (bounceLife <= 0) { bounceLife = 0; bounceShape = null; }
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();

    if (shakeIntensity > 0) {
      ctx.translate((Math.random() - 0.5) * shakeIntensity, (Math.random() - 0.5) * shakeIntensity);
      shakeIntensity *= 0.8;
      if (shakeIntensity < 0.3) shakeIntensity = 0;
    }

    // 背景格
    ctx.fillStyle = '#333';
    for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) {
      const x = layout.gridX + c * CELL_SIZE + 2;
      const y = layout.gridY + r * CELL_SIZE + 2;
      ctx.fillRect(x, y, CELL_SIZE - 4, CELL_SIZE - 4);
    }

    if (currentTheme) {
      // 已放方塊（含 clearing 動畫）
      for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) {
        const cell = grid[r][c];
        if (cell === 1 || cell === 2) {
          const x = layout.gridX + c * CELL_SIZE + 2;
          const y = layout.gridY + r * CELL_SIZE + 2;

          if (cell === 1) {
            drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, 1);
          } else {
            const key = `${r},${c}`;
            const cc = clearingMap.get(key);
            const life = cc ? Math.max(0, cc.life) : 0.5;

            drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, 0.25 + 0.75 * life);

            ctx.save();
            ctx.globalAlpha = 0.35 * life;
            ctx.fillStyle = "rgba(255,255,255,1)";
            pathRoundedRect(x, y, CELL_SIZE - 4, CELL_SIZE - 4, 8);
            ctx.fill();
            ctx.restore();
          }
        }
      }

      updateAndDrawLineFlashes();

      // 拖曳 preview + 本體
      if (draggingIdx !== null && hand[draggingIdx]) {
        const shape = hand[draggingIdx];
        const anchorX = dragNowAX;
        const anchorY = dragNowAY;

        const best = findBestMagnet(shape, anchorX, anchorY);

        let previewR, previewC;
        if (best.can) { previewR = best.r; previewC = best.c; }
        else {
          previewR = Math.floor((anchorY - layout.gridY) / CELL_SIZE);
          previewC = Math.floor((anchorX - layout.gridX) / CELL_SIZE);
        }

        if (canPlace(shape, previewR, previewC)) {
          for (const coord of shape) {
            const x = layout.gridX + (previewC + coord[1]) * CELL_SIZE + 2;
            const y = layout.gridY + (previewR + coord[0]) * CELL_SIZE + 2;
            drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, PREVIEW_ALPHA_OK);
          }
        } else {
          ctx.save();
          ctx.globalAlpha = PREVIEW_ALPHA_BAD;
          ctx.fillStyle = "rgba(255,80,80,1)";
          ctx.fillRect(layout.gridX, layout.gridY, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
          ctx.restore();
        }

        const drawX = anchorX;
        const drawY = anchorY - DRAG_LIFT;
        for (const coord of shape) {
          const x = drawX + coord[1] * CELL_SIZE;
          const y = drawY + coord[0] * CELL_SIZE;
          drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, 1);
        }
      }

      drawHand();
      updateAndDrawParticles();
      updateAndDrawBounce();
      updateAndDrawFloatingTexts();
    }

    // 失敗紅色 overlay（透明度可調）
    if (failOverlayLife > 0) {
      ctx.save();
      ctx.globalAlpha = 0.30 * failOverlayLife;
      ctx.fillStyle = "rgba(255, 60, 60, 1)";
      ctx.fillRect(layout.gridX, layout.gridY, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
      ctx.restore();
      failOverlayLife -= 0.06;
      if (failOverlayLife < 0) failOverlayLife = 0;
    }

    ctx.restore();

    // ✅ clearing 動畫更新（真正清格）
    updateClearingCells();

    requestAnimationFrame(animate);
  }

  window.addEventListener('resize', () => applyLayout(computeLayout()));

  // ===== Boot =====
  (function boot() {
    const n = getPlayerName();
    if (n) nameInput.value = n;
    syncPlayerMini();

    applyLayout(computeLayout());
    resetGame();

    showOverlay();
    switchTab("login");
    animate();
  })();
</script>

</body>
</html>
