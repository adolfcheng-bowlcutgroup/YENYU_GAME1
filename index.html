<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>9x9 拼圖消消樂</title>
  <style>
    * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
    body {
      background-color: #1a1a1a;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
      height: 100dvh;
      justify-content: center;
      overflow: hidden;
    }
    .header {
      width: 100%;
      max-width: 600px;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      position: relative;
      margin-bottom: 10px;
      padding: 0 10px;
    }
    #highScoreContainer {
      position: absolute; left: 10px; bottom: 5px;
      background: rgba(255, 255, 255, 0.1);
      padding: 5px 10px; border-radius: 5px; border-left: 4px solid #FFD700;
    }
    #scoreDisplay {
      font-size: clamp(40px, 10vw, 70px);
      font-weight: bold;
      font-family: 'Arial Black', sans-serif;
    }
    #gameWrapper {
      position: relative;
      width: 95vw;
      max-width: 800px;
      display: flex;
      justify-content: center;
    }
    canvas {
      background-color: #222;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      width: 100%;
      height: auto;
      display: block;
      touch-action: none;
    }
    #restartBtn {
      display: none;
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      padding: 15px 40px; font-size: 20px; font-weight: bold;
      color: white; border: none; border-radius: 30px;
      cursor: pointer; z-index: 100;
    }
  </style>
</head>
<body>

  <div class="header">
    <div id="highScoreContainer">
      <div style="font-size:10px;color:#aaa;">BEST</div>
      <div id="highScore">0</div>
    </div>
    <div id="scoreDisplay">0</div>
  </div>

  <div id="gameWrapper">
    <canvas id="gameCanvas"></canvas>
    <button id="restartBtn" onclick="resetGame()">PLAY AGAIN</button>
  </div>

<script>
/** =========================
 *  核心設定
 *  ========================= */
const GRID_SIZE = 9;
const CELL_SIZE = 55;

const SIDEBAR_W = 250;   // 桌機右側手牌寬
const BOTTOMBAR_H = 220; // 手機底部手牌高

// 磁吸（更聰明：附近搜尋）
const MAGNET_SEARCH_RADIUS = 2;   // 2 => 搜 5x5
const MAGNET_DISTANCE = 0.55;     // 手指靠近格子中心多少比例會吸
const PREVIEW_ALPHA_OK = 0.28;
const PREVIEW_ALPHA_BAD = 0.14;

// 拖曳顯示（避免遮擋）
let dragOffsetX = CELL_SIZE * 0.45;
let dragOffsetY = CELL_SIZE * 0.45;
const DRAG_LIFT = CELL_SIZE * 0.9;

// 失敗回饋（震動＋紅色提示＋回彈）
const FAIL_SHAKE = 14;
const FAIL_VIBRATION_PATTERN = [25, 30, 25];
let failOverlayLife = 0;     // 紅色提示
let bounceLife = 0;          // 回彈動畫
let bounceFromX = 0, bounceFromY = 0;
let bounceToX = 0, bounceToY = 0;
let bounceShape = null;
let bounceTheme = null;

// 特效（清除閃光/粒子）
let particles = [];
let lineFlashes = [];

// 判斷手機布局
function isMobileLayout() {
  return window.matchMedia("(max-width: 600px)").matches;
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const restartBtn = document.getElementById('restartBtn');

const THEMES = [
  { main: '#4A90E2', dark: '#21508A', light: '#A4C8F5' },
  { main: '#50E3C2', dark: '#2A8F79', light: '#B2F2E5' },
  { main: '#F5A623', dark: '#A36B0D', light: '#FCD9A1' }
];

const SHAPE_DEFS = [
  { shape: [[0,0], [0,1]], weight: 10 },
  { shape: [[0,0], [1,0]], weight: 10 },
  { shape: [[0,0], [0,1], [1,0], [1,1]], weight: 10 },
  { shape: [[0,0], [0,1], [0,2]], weight: 10 },
  { shape: [[0,0], [1,0], [2,0]], weight: 10 },
  { shape: [[0,0], [1,0], [1,1]], weight: 10 },
  { shape: [[0,0]], weight: 10 },
  { shape: [[0,0], [0,1], [0,2], [0,3]], weight: 10 },
  { shape: [[0,0], [1,0], [2,0], [3,0]], weight: 10 },
  { shape: [[0,0], [1,0], [1,1], [2,1]], weight: 10 },
  { shape: [[0,1], [0,2], [1,0], [1,1]], weight: 10 },
  { shape: [[0,1], [1,0], [1,1], [1,2]], weight: 10 },
  { shape: [[0,0], [1,0], [2,0], [2,1]], weight: 10 },
  { shape: [[0,0], [0,1], [0,2], [1,0], [2,0]], weight: 3 },
  { shape: [[0,1], [1,0], [1,1], [1,2], [2,1]], weight: 3 },
  { shape: [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2], [2,0], [2,1], [2,2]], weight: 3 }
];

/** =========================
 *  狀態
 *  ========================= */
let currentTheme;
let grid, hand, score, highScore;
let draggingIdx = null;
let pointerX = 0, pointerY = 0;
let gameOver = false;

let floatingTexts = [];
let shakeIntensity = 0;
let currentComboCount = 0;

let layout = null; // { mode, rawW, rawH, gridX, gridY, hand:{slots...}, handBlock, handGap }

/** =========================
 *  Layout
 *  ========================= */
function computeLayout() {
  const mobile = isMobileLayout();
  if (mobile) {
    const rawW = GRID_SIZE * CELL_SIZE;
    const rawH = GRID_SIZE * CELL_SIZE + BOTTOMBAR_H;

    const handX = 0;
    const handY = GRID_SIZE * CELL_SIZE;
    const handW = rawW;
    const handH = BOTTOMBAR_H;

    const padX = 20;
    const padY = 25;
    const slotW = (handW - padX * 2) / 3;
    const slotH = handH - padY * 2;

    const slots = [0,1,2].map(i => ({
      x: handX + padX + i * slotW,
      y: handY + padY,
      w: slotW,
      h: slotH
    }));

    return {
      mode: "mobile",
      rawW, rawH,
      gridX: 0, gridY: 0,
      hand: { x: handX, y: handY, w: handW, h: handH, slots },
      handBlock: 24,
      handGap: 4
    };
  } else {
    const rawW = GRID_SIZE * CELL_SIZE + SIDEBAR_W;
    const rawH = GRID_SIZE * CELL_SIZE;

    const handX = GRID_SIZE * CELL_SIZE;
    const handY = 0;
    const handW = SIDEBAR_W;
    const handH = rawH;

    const slots = [0,1,2].map(i => ({
      x: handX + 20,
      y: 40 + i * 150,
      w: handW - 40,
      h: 120
    }));

    return {
      mode: "desktop",
      rawW, rawH,
      gridX: 0, gridY: 0,
      hand: { x: handX, y: handY, w: handW, h: handH, slots },
      handBlock: 20,
      handGap: 2
    };
  }
}

function applyLayout(newLayout) {
  layout = newLayout;
  canvas.width = layout.rawW;
  canvas.height = layout.rawH;
}

/** =========================
 *  繪圖工具
 *  ========================= */
function pathRoundedRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function drawBlock(x, y, size, r, theme, alpha = 1.0) {
  ctx.save();
  ctx.globalAlpha = alpha;
  pathRoundedRect(x, y, size, size, r);
  const g = ctx.createLinearGradient(x, y, x + size, y + size);
  g.addColorStop(0, theme.light);
  g.addColorStop(1, theme.dark);
  ctx.fillStyle = g;
  ctx.fill();
  ctx.fillStyle = "rgba(255,255,255,0.2)";
  ctx.beginPath();
  ctx.arc(x + size*0.3, y + size*0.3, size*0.15, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

/** =========================
 *  遊戲流程
 *  ========================= */
function resetGame() {
  applyLayout(computeLayout());

  currentTheme = THEMES[Math.floor(Math.random() * THEMES.length)];
  restartBtn.style.backgroundColor = currentTheme.main;

  grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
  score = 0;
  highScore = Number(localStorage.getItem('blockHighScore') || 0);

  gameOver = false;
  floatingTexts = [];
  currentComboCount = 0;
  shakeIntensity = 0;
  particles = [];
  lineFlashes = [];
  failOverlayLife = 0;
  bounceLife = 0;

  document.getElementById('scoreDisplay').innerText = "0";
  document.getElementById('highScore').innerText = String(highScore);
  restartBtn.style.display = "none";

  refreshHand();
}

function refreshHand() {
  hand = [];
  for (let i = 0; i < 3; i++) {
    const totalW = SHAPE_DEFS.reduce((s, x) => s + x.weight, 0);
    let rand = Math.random() * totalW;
    let chosen = SHAPE_DEFS[0].shape;
    for (const def of SHAPE_DEFS) {
      if (rand < def.weight) { chosen = def.shape; break; }
      rand -= def.weight;
    }
    hand.push(chosen);
  }
}

function canPlace(shape, r, c) {
  if (!shape || r < 0 || c < 0) return false;
  for (let i = 0; i < shape.length; i++) {
    const nr = r + shape[i][0];
    const nc = c + shape[i][1];
    if (nr >= GRID_SIZE || nc >= GRID_SIZE || grid[nr][nc] === 1) return false;
  }
  return true;
}

/** =========================
 *  特效（粒子/閃光）
 *  ========================= */
function spawnClearParticles(cells) {
  for (const {r, c} of cells) {
    const cx = layout.gridX + c * CELL_SIZE + CELL_SIZE / 2;
    const cy = layout.gridY + r * CELL_SIZE + CELL_SIZE / 2;

    const n = 10 + Math.floor(Math.random() * 5);
    for (let i = 0; i < n; i++) {
      const ang = Math.random() * Math.PI * 2;
      const spd = 2 + Math.random() * 5;
      particles.push({
        x: cx, y: cy,
        vx: Math.cos(ang) * spd,
        vy: Math.sin(ang) * spd - 1.2,
        life: 1,
        size: 2 + Math.random() * 3
      });
    }
  }
}

function updateAndDrawParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life -= 0.03;
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.18;
    p.vx *= 0.98;
    p.vy *= 0.98;

    if (p.life <= 0) { particles.splice(i, 1); continue; }

    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = "rgba(255, 215, 0, 1)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

function spawnLineFlash(rows, cols) {
  for (const r of rows) lineFlashes.push({ type: 'row', idx: r, life: 1 });
  for (const c of cols) lineFlashes.push({ type: 'col', idx: c, life: 1 });
}

function updateAndDrawLineFlashes() {
  for (let i = lineFlashes.length - 1; i >= 0; i--) {
    const f = lineFlashes[i];
    f.life -= 0.06;
    if (f.life <= 0) { lineFlashes.splice(i, 1); continue; }

    ctx.save();
    ctx.globalAlpha = Math.max(0, f.life);
    ctx.fillStyle = "rgba(255,255,255,0.65)";

    if (f.type === 'row') {
      const y = layout.gridY + f.idx * CELL_SIZE;
      ctx.fillRect(layout.gridX, y, GRID_SIZE * CELL_SIZE, CELL_SIZE);
    } else {
      const x = layout.gridX + f.idx * CELL_SIZE;
      ctx.fillRect(x, layout.gridY, CELL_SIZE, GRID_SIZE * CELL_SIZE);
    }
    ctx.restore();
  }
}

/** =========================
 *  清除＆計分
 *  ========================= */
function checkAndClear() {
  const rs = [], cs = [];

  for (let r = 0; r < GRID_SIZE; r++) {
    if (grid[r].every(v => v === 1)) rs.push(r);
  }
  for (let c = 0; c < GRID_SIZE; c++) {
    let full = true;
    for (let r = 0; r < GRID_SIZE; r++) if (grid[r][c] === 0) full = false;
    if (full) cs.push(c);
  }

  if (rs.length + cs.length > 0) {
    // 特效：收集被清掉格子
    const clearedSet = new Set();
    for (const r of rs) for (let c = 0; c < GRID_SIZE; c++) clearedSet.add(`${r},${c}`);
    for (const c of cs) for (let r = 0; r < GRID_SIZE; r++) clearedSet.add(`${r},${c}`);
    const clearedCells = Array.from(clearedSet).map(s => {
      const [r, c] = s.split(',').map(Number);
      return { r, c };
    });

    spawnLineFlash(rs, cs);
    spawnClearParticles(clearedCells);

    currentComboCount++;
    const lines = rs.length + cs.length;
    const gain = (lines * GRID_SIZE) + (lines - 1) * 5 + (currentComboCount * 5);
    score += gain;

    document.getElementById('scoreDisplay').innerText = String(score);

    if (score > highScore) {
      highScore = score;
      localStorage.setItem('blockHighScore', String(score));
      document.getElementById('highScore').innerText = String(score);
    }

    shakeIntensity = Math.max(shakeIntensity, lines * 8);

    const praise = ["", "Good！", "Nice Play！", "Great！", "Perfect！", "GOD LIKE！"][Math.min(currentComboCount, 5)];
    floatingTexts.push({
      txt: praise,
      x: layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
      y: layout.gridY + (GRID_SIZE * CELL_SIZE) / 2 - 30,
      life: 1,
      size: 25 + currentComboCount * 5
    });

    rs.forEach(r => { for (let c = 0; c < GRID_SIZE; c++) grid[r][c] = 0; });
    cs.forEach(c => { for (let r = 0; r < GRID_SIZE; r++) grid[r][c] = 0; });

  } else {
    currentComboCount = 0;
  }
}

/** =========================
 *  座標換算
 *  ========================= */
function getCanvasPosFromClient(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (canvas.width / (rect.width || 1));
  const y = (clientY - rect.top) * (canvas.height / (rect.height || 1));
  return { x, y };
}

/** =========================
 *  手牌命中 / 手牌 slot 中心點
 *  ========================= */
function pickHandIndex(pos) {
  const { slots } = layout.hand;
  for (let i = 0; i < slots.length; i++) {
    const s = slots[i];
    if (pos.x >= s.x && pos.x <= s.x + s.w && pos.y >= s.y && pos.y <= s.y + s.h) {
      if (hand[i]) return i;
    }
  }
  return null;
}

function shapeBoundingBox(shape) {
  let minR = Infinity, minC = Infinity, maxR = -Infinity, maxC = -Infinity;
  for (const [r,c] of shape) {
    minR = Math.min(minR, r); minC = Math.min(minC, c);
    maxR = Math.max(maxR, r); maxC = Math.max(maxC, c);
  }
  return { minR, minC, maxR, maxC, w: maxC - minC + 1, h: maxR - minR + 1 };
}

function getHandSlotCenterForShape(idx, shape) {
  const slot = layout.hand.slots[idx];
  const bb = shapeBoundingBox(shape);
  const block = layout.handBlock;
  const gap = layout.handGap;

  const shapeW = bb.w * (block + gap) - gap;
  const shapeH = bb.h * (block + gap) - gap;

  const startX = slot.x + (slot.w - shapeW) / 2;
  const startY = slot.y + (slot.h - shapeH) / 2;

  // 以 shape 的 anchor (minR/minC 對應的相對位置) 的中心回去推
  const anchorX = startX + (0 - bb.minC) * (block + gap) + block / 2;
  const anchorY = startY + (0 - bb.minR) * (block + gap) + block / 2;

  return { x: anchorX, y: anchorY };
}

/** =========================
 *  磁吸：找「附近最近且可放置」的格子
 *  ========================= */
function findBestMagnet(shape, posX, posY) {
  // pointer 在 grid 座標
  const gx = (posX - layout.gridX) / CELL_SIZE;
  const gy = (posY - layout.gridY) / CELL_SIZE;

  const baseC = Math.round(gx);
  const baseR = Math.round(gy);

  let best = null;

  // 先找最近且可放置
  for (let dr = -MAGNET_SEARCH_RADIUS; dr <= MAGNET_SEARCH_RADIUS; dr++) {
    for (let dc = -MAGNET_SEARCH_RADIUS; dc <= MAGNET_SEARCH_RADIUS; dc++) {
      const r = baseR + dr;
      const c = baseC + dc;
      if (r < 0 || c < 0 || r >= GRID_SIZE || c >= GRID_SIZE) continue;
      if (!canPlace(shape, r, c)) continue;

      const snappedX = layout.gridX + c * CELL_SIZE;
      const snappedY = layout.gridY + r * CELL_SIZE;

      const dx = (posX - snappedX) / CELL_SIZE;
      const dy = (posY - snappedY) / CELL_SIZE;
      const distNorm = Math.hypot(dx, dy);

      if (best === null || distNorm < best.distNorm) {
        best = { r, c, snappedX, snappedY, distNorm };
      }
    }
  }

  if (!best) {
    // 沒有可放置，仍回傳最近格（用於預覽 red/alpha）
    const r = baseR, c = baseC;
    const snappedX = layout.gridX + c * CELL_SIZE;
    const snappedY = layout.gridY + r * CELL_SIZE;
    const dx = (posX - snappedX) / CELL_SIZE;
    const dy = (posY - snappedY) / CELL_SIZE;
    const distNorm = Math.hypot(dx, dy);
    return { r, c, snappedX, snappedY, distNorm, can: false };
  }
  return { ...best, can: true };
}

/** =========================
 *  失敗回饋（震動＋抖動＋紅色提示＋回彈）
 *  ========================= */
function failFeedback() {
  shakeIntensity = Math.max(shakeIntensity, FAIL_SHAKE);
  failOverlayLife = 1;

  floatingTexts.push({
    txt: "放不下！",
    x: layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
    y: layout.gridY + (GRID_SIZE * CELL_SIZE) / 2,
    life: 1,
    size: 28
  });

  if (navigator.vibrate) {
    try { navigator.vibrate(FAIL_VIBRATION_PATTERN); } catch (_) {}
  }
}

function startBounceBack(idx, shape, fromX, fromY) {
  bounceLife = 1;
  bounceShape = shape;
  bounceTheme = currentTheme;

  bounceFromX = fromX;
  bounceFromY = fromY;

  const home = getHandSlotCenterForShape(idx, shape);
  bounceToX = home.x;
  bounceToY = home.y;
}

/** =========================
 *  輸入（Pointer Events）
 *  ========================= */
function handlePointerDown(e) {
  if (gameOver) return;

  canvas.setPointerCapture?.(e.pointerId);

  const pos = getCanvasPosFromClient(e.clientX, e.clientY);
  pointerX = pos.x; pointerY = pos.y;

  const idx = pickHandIndex(pos);
  if (idx !== null) {
    draggingIdx = idx;

    // 抓起來的位置偏移：讓方塊貼手但不跳位
    dragOffsetX = CELL_SIZE * 0.45;
    dragOffsetY = CELL_SIZE * 0.45;
  }
}

// 取 coalesced 的最後一筆，跟手更即時
function handlePointerMove(e) {
  const events = (e.getCoalescedEvents && e.getCoalescedEvents()) || null;
  const last = events && events.length ? events[events.length - 1] : e;

  const pos = getCanvasPosFromClient(last.clientX, last.clientY);
  pointerX = pos.x; pointerY = pos.y;
}

function handlePointerUpOrCancel() {
  if (draggingIdx === null) return;

  const shape = hand[draggingIdx];
  if (shape) {
    // 計算拖曳圖形目前顯示位置（用於失敗回彈起點）
    const best = findBestMagnet(shape, pointerX, pointerY);
    const shouldMagnet = best.can && best.distNorm <= MAGNET_DISTANCE;

    let drawX, drawY;
    if (shouldMagnet) {
      drawX = best.snappedX + CELL_SIZE * 0.10;
      drawY = best.snappedY + CELL_SIZE * 0.10 - (DRAG_LIFT * 0.35);
    } else {
      drawX = pointerX - dragOffsetX;
      drawY = pointerY - dragOffsetY - DRAG_LIFT;
    }

    // 取落點：磁吸成功就用 best；不然用自由落點
    let r, c;
    if (shouldMagnet) {
      r = best.r; c = best.c;
    } else {
      r = Math.floor((pointerY - layout.gridY) / CELL_SIZE);
      c = Math.floor((pointerX - layout.gridX) / CELL_SIZE);
    }

    if (canPlace(shape, r, c)) {
      for (const coord of shape) {
        grid[r + coord[0]][c + coord[1]] = 1;
      }
      hand[draggingIdx] = null;

      checkAndClear();

      if (hand.every(h => h === null)) refreshHand();

      // 死局判斷
      let dead = true;
      for (const s of hand) {
        if (!s) continue;
        for (let i = 0; i < GRID_SIZE; i++) {
          for (let j = 0; j < GRID_SIZE; j++) {
            if (canPlace(s, i, j)) { dead = false; break; }
          }
          if (!dead) break;
        }
        if (!dead) break;
      }
      if (dead) gameOver = true;

    } else {
      // 失敗：震動＋紅提示＋回彈
      failFeedback();
      startBounceBack(draggingIdx, shape, drawX, drawY);
    }
  }

  draggingIdx = null;
}

canvas.addEventListener('pointerdown', handlePointerDown);
window.addEventListener('pointermove', handlePointerMove);
window.addEventListener('pointerup', handlePointerUpOrCancel);
window.addEventListener('pointercancel', handlePointerUpOrCancel);
// 低延遲（支援就更順）
window.addEventListener('pointerrawupdate', handlePointerMove);

/** =========================
 *  繪製：手牌
 *  ========================= */
function drawHand() {
  const { slots } = layout.hand;

  // 手機底部手牌區背景
  if (layout.mode === "mobile") {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(layout.hand.x, layout.hand.y, layout.hand.w, layout.hand.h);
    ctx.restore();
  }

  for (let i = 0; i < 3; i++) {
    const shape = hand[i];
    const slot = slots[i];

    // slot 框（點選範圍）
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 2;
    pathRoundedRect(slot.x + 6, slot.y + 6, slot.w - 12, slot.h - 12, 14);
    ctx.stroke();
    ctx.restore();

    if (!shape || i === draggingIdx) continue;

    const bb = shapeBoundingBox(shape);
    const block = layout.handBlock;
    const gap = layout.handGap;

    const shapeW = bb.w * (block + gap) - gap;
    const shapeH = bb.h * (block + gap) - gap;

    const startX = slot.x + (slot.w - shapeW) / 2;
    const startY = slot.y + (slot.h - shapeH) / 2;

    for (const coord of shape) {
      const x = startX + (coord[1] - bb.minC) * (block + gap);
      const y = startY + (coord[0] - bb.minR) * (block + gap);
      drawBlock(x, y, block, 6, currentTheme, 1);
    }
  }
}

/** =========================
 *  繪製：回彈動畫
 *  ========================= */
function updateAndDrawBounce() {
  if (bounceLife <= 0 || !bounceShape || !bounceTheme) return;

  // easeOutBack：回彈很爽
  const t = 1 - bounceLife;
  const c1 = 1.70158;
  const c3 = c1 + 1;
  const easeOutBack = (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);

  const k = easeOutBack(Math.min(1, Math.max(0, t)));

  // 以「anchor」中心插值，畫時再轉成左上角
  const cx = bounceFromX + (bounceToX - bounceFromX) * k;
  const cy = bounceFromY + (bounceToY - bounceFromY) * k;

  // 這裡 bounceFrom/bounceTo 是以 shape anchor 近似點，所以直接用它當左上角略偏
  // 為了視覺好看，做小修正：回彈過程縮小一點點再回來
  const scale = 0.98 + 0.04 * (1 - Math.abs(0.5 - t) * 2);

  ctx.save();
  ctx.globalAlpha = 0.95 * bounceLife;

  // 把 shape 畫成 CELL_SIZE 的尺寸（跟拖曳時一致）
  for (const coord of bounceShape) {
    const x = cx + coord[1] * CELL_SIZE;
    const y = cy + coord[0] * CELL_SIZE;
    // scale 以格子左上角為基準
    const sx = x + (CELL_SIZE - 4) * (1 - scale) * 0.5;
    const sy = y + (CELL_SIZE - 4) * (1 - scale) * 0.5;
    drawBlock(sx, sy, (CELL_SIZE - 4) * scale, 8, bounceTheme, ctx.globalAlpha);
  }

  ctx.restore();

  bounceLife -= 0.06;
  if (bounceLife <= 0) {
    bounceLife = 0;
    bounceShape = null;
  }
}

/** =========================
 *  animate
 *  ========================= */
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();

  // 抖動
  if (shakeIntensity > 0) {
    ctx.translate((Math.random() - 0.5) * shakeIntensity, (Math.random() - 0.5) * shakeIntensity);
    shakeIntensity *= 0.8;
    if (shakeIntensity < 0.3) shakeIntensity = 0;
  }

  // 棋盤背景
  ctx.fillStyle = '#333';
  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
      const x = layout.gridX + c * CELL_SIZE + 2;
      const y = layout.gridY + r * CELL_SIZE + 2;
      ctx.fillRect(x, y, CELL_SIZE - 4, CELL_SIZE - 4);
    }
  }

  if (currentTheme) {
    // 固定方塊
    for (let r = 0; r < GRID_SIZE; r++) {
      for (let c = 0; c < GRID_SIZE; c++) {
        if (grid[r][c]) {
          const x = layout.gridX + c * CELL_SIZE + 2;
          const y = layout.gridY + r * CELL_SIZE + 2;
          drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, 1);
        }
      }
    }

    // 清除閃光（在方塊上方）
    updateAndDrawLineFlashes();

    // 拖曳
    if (draggingIdx !== null && hand[draggingIdx]) {
      const shape = hand[draggingIdx];

      const best = findBestMagnet(shape, pointerX, pointerY);
      const shouldMagnet = best.can && best.distNorm <= MAGNET_DISTANCE;

      // 預覽落點（若可放）
      let previewR, previewC;
      if (shouldMagnet) { previewR = best.r; previewC = best.c; }
      else {
        previewR = Math.floor((pointerY - layout.gridY) / CELL_SIZE);
        previewC = Math.floor((pointerX - layout.gridX) / CELL_SIZE);
      }

      if (canPlace(shape, previewR, previewC)) {
        for (const coord of shape) {
          const x = layout.gridX + (previewC + coord[1]) * CELL_SIZE + 2;
          const y = layout.gridY + (previewR + coord[0]) * CELL_SIZE + 2;
          drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, PREVIEW_ALPHA_OK);
        }
      } else {
        // 放不下預覽：淡淡紅
        ctx.save();
        ctx.globalAlpha = PREVIEW_ALPHA_BAD;
        ctx.fillStyle = "rgba(255,80,80,1)";
        ctx.fillRect(layout.gridX, layout.gridY, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
        ctx.restore();
      }

      // 拖曳顯示位置：跟手 + 上抬，或磁吸吸到格子
      let drawX, drawY;
      if (shouldMagnet) {
        drawX = best.snappedX + CELL_SIZE * 0.10;
        drawY = best.snappedY + CELL_SIZE * 0.10 - (DRAG_LIFT * 0.35);
      } else {
        drawX = pointerX - dragOffsetX;
        drawY = pointerY - dragOffsetY - DRAG_LIFT;
      }

      for (const coord of shape) {
        const x = drawX + coord[1] * CELL_SIZE;
        const y = drawY + coord[0] * CELL_SIZE;
        drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, 1);
      }
    }

    // 手牌
    drawHand();

    // 粒子（最上層）
    updateAndDrawParticles();

    // 回彈（最上層，覆蓋拖曳後的殘影感）
    updateAndDrawBounce();
  }

  // 失敗紅色提示 overlay
  if (failOverlayLife > 0) {
    ctx.save();
    ctx.globalAlpha = 0.35 * failOverlayLife;
    ctx.fillStyle = "rgba(255, 60, 60, 1)";
    ctx.fillRect(layout.gridX, layout.gridY, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
    ctx.restore();
    failOverlayLife -= 0.06;
    if (failOverlayLife < 0) failOverlayLife = 0;
  }

  // 浮字
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y -= 1;
    t.life -= 0.02;

    ctx.globalAlpha = Math.max(0, t.life);
    ctx.fillStyle = "#FFD700";
    ctx.textAlign = "center";
    ctx.font = "bold " + t.size + "px Arial";
    ctx.fillText(t.txt, t.x, t.y);

    if (t.life <= 0) floatingTexts.splice(i, 1);
  }
  ctx.globalAlpha = 1;

  // GAME OVER
  if (gameOver) {
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white";
    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
    restartBtn.style.display = "block";
  }

  ctx.restore();
  requestAnimationFrame(animate);
}

/** =========================
 *  resize：切換布局（不重置遊戲）
 *  ========================= */
function handleResize() {
  const prevMode = layout?.mode;
  const newLayout = computeLayout();
  if (!layout || prevMode !== newLayout.mode) {
    applyLayout(newLayout);
  } else {
    applyLayout(newLayout);
  }
}
window.addEventListener('resize', handleResize);

/** =========================
 *  啟動
 *  ========================= */
resetGame();
animate();
</script>

</body>
</html>
