<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>晏羽のミニゲーム！</title>
  <style>
    * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
    body{
      background:#1a1a1a; color:#fff; margin:0;
      height:100vh; height:100dvh;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      font-family: Arial, sans-serif;
      overflow:hidden;
    }

    .header{
      width:100%; max-width:720px;
      display:flex; justify-content:center; align-items:flex-end;
      position:relative; margin-bottom:10px; padding:0 10px;
    }
    #highScoreContainer{
      position:absolute; left:10px; bottom:5px;
      background:rgba(255,255,255,0.1);
      padding:5px 10px; border-radius:5px; border-left:4px solid #FFD700;
    }
    #scoreDisplay{
      font-size:clamp(40px, 10vw, 70px);
      font-weight:900;
      font-family:'Arial Black', sans-serif;
      user-select:none; -webkit-user-select:none;
    }
    #comboBadge{
      position:absolute; right:10px; bottom:5px;
      z-index: 50;
      color:white;
      background:rgba(255,255,255,0.10);
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.18);
      display:none;
      font-weight:900;
      letter-spacing:.5px;
      user-select:none; -webkit-user-select:none;
      pointer-events:none;
    }
    #comboBadge .label{ font-size:10px; color:#aaa; margin-right:6px; font-weight:700; }
    #comboBadge .value{ font-size:14px; }

    #gameWrapper{
      position:relative;
      width:95vw; max-width:860px;
      display:flex; justify-content:center;
    }

    canvas{
      background:#222;
      border-radius:12px;
      box-shadow:0 10px 40px rgba(0,0,0,0.5);
      width:100%; height:auto; display:block;
      touch-action:none;
    }
    #restartBtn{
      display:none;
      position:absolute; top:50%; left:50%;
      transform:translate(-50%, -50%);
      padding:15px 40px; font-size:20px; font-weight:900;
      color:#fff; border:none; border-radius:30px;
      cursor:pointer; z-index:100;
    }

    /* ========== Login / Menu Overlay ========== */
    #overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.78);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 20px;
    }

    #viewBoard{
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .panel{
      width:min(580px, 95vw);
      background: rgba(25,25,25,0.98);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 18px;
      box-shadow: 0 20px 80px rgba(0,0,0,0.6);
      overflow: hidden;
      max-height: min(86vh, 720px);
      display: flex;
      flex-direction: column;
    }
    .panelHead{
      padding: 16px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
    }
    .panelHead .title{
      font-weight: 900;
      letter-spacing: .5px;
      font-size: 16px;
    }
    .panelBody{
      padding: 16px 18px 18px;
      overflow: hidden;   /* 重要：讓裡面可捲動區生效 */
      display: flex;
      flex-direction: column;
    }

    .tabs{
      display:flex; gap:10px;
      margin-bottom: 14px;
    }
    .tabBtn{
      flex:1;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.10);
      color:#fff;
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 800;
    }

    .tabBtn.active{
      background: rgba(255,255,255,0.14);
      border-color: rgba(255,255,255,0.20);
      box-shadow: 0 0 18px rgba(255,255,255,0.08);
    }

    .row{
      display:flex;
      gap:10px;
      margin: 10px 0;
      align-items:center;
    }
    .label2{
      width: 86px;
      color: rgba(255,255,255,0.70);
      font-weight: 700;
      font-size: 13px;
    }
    input[type="text"]{
      flex:1;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      color:#fff;
      padding: 10px 12px;
      border-radius: 12px;
      outline: none;
      font-size: 14px;
      font-weight: 800;
    }
    input[type="text"]::placeholder{ color: rgba(255,255,255,0.35); }

    .actions{
      display:flex; gap:10px;
      margin-top: 14px;
    }
    .btn{
      flex:1;
      border:none;
      border-radius: 14px;
      padding: 12px 14px;
      font-weight: 900;
      cursor:pointer;
      color:#111;
    }
    .btnPrimary{
      background: #FFD700;
    }
    .btnGhost{
      background: rgba(255,255,255,0.10);
      color:#fff;
      border: 1px solid rgba(255,255,255,0.12);
    }
    .hint{
      margin-top: 10px;
      color: rgba(255,255,255,0.55);
      font-size: 12px;
      line-height: 1.5;
    }

    .board{
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      background: rgba(255,255,255,0.04);
      flex: 1;
      min-height: 260px;
      max-height: 52vh;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .boardHeader, .boardRow{
      display:grid;
      grid-template-columns: 52px minmax(0, 1fr) 92px 78px; /* ✅ 更省空間 */
      gap: 8px;
      padding: 10px 12px;
      align-items:center;
    }
    .boardHeader{
      background: rgba(255,255,255,0.06);
      font-size: 12px;
      color: rgba(255,255,255,0.70);
      font-weight: 900;
      letter-spacing: .4px;
    }
    .boardRow{
      border-top: 1px solid rgba(255,255,255,0.06);
      font-size: 14px;
      font-weight: 800;
    }
    .rankPill{
      width: 38px; height: 26px;
      border-radius: 999px;
      display:flex; align-items:center; justify-content:center;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.10);
      font-size: 12px;
      font-weight: 900;
      color: rgba(255,255,255,0.88);
    }
    .muted{
      color: rgba(255,255,255,0.60);
      font-weight: 800;
    }
    .right{
      text-align:right;
    }
    .meRow{
      background: rgba(255,215,0,0.10);
      border-top: 1px solid rgba(255,215,0,0.22);
    }
    .sep{
      height: 1px;
      background: rgba(255,255,255,0.10);
      margin: 10px 0;
    }
    .smallNote{
      font-size: 12px;
      color: rgba(255,255,255,0.60);
      margin-top: 10px;
      line-height: 1.5; 
    }
     .nameCell{
      min-width: 0;              /* ✅ 讓省略號真的能生效 */
      white-space: nowrap;       /* ✅ 不換行 */
      overflow: hidden;          /* ✅ 截斷 */
      text-overflow: ellipsis;   /* ✅ 省略號 */
    }
  </style>
</head>
<body>

  <div class="header">
    <div id="highScoreContainer">
      <div style="font-size:10px;color:#aaa;">個人最高分</div>
      <div id="highScore">0</div>
    </div>

    <div id="scoreDisplay">0</div>

    <div id="comboBadge">
      <span class="label">COMBO</span>
      <span class="value" id="comboCount">x0</span>
    </div>
  </div>

  <div id="gameWrapper">
    <canvas id="gameCanvas"></canvas>
    <button id="restartBtn">PLAY AGAIN</button>
  </div>

  <!-- Overlay: Login / Leaderboard -->
  <div id="overlay">
    <div class="panel">
      <div class="panelHead">
        <div class="title">晏羽の迷你小遊戲！</div>
        <div id="playerMini" class="muted"></div>
      </div>

      <div class="panelBody">
        <div class="tabs">
          <button id="tabLogin" class="tabBtn active">登入 / 取名</button>
          <button id="tabBoard" class="tabBtn">排行榜</button>
        </div>

        <div id="viewLogin">
          <div class="row">
            <div class="label2">玩家名字</div>
            <input id="nameInput" type="text" maxlength="16" placeholder="輸入暱稱（最多 16 字）" />
          </div>

          <div class="actions">
            <button id="btnStart" class="btn btnPrimary">開始遊戲</button>
            <button id="btnToBoard" class="btn btnGhost">看排行榜</button>
          </div>

          <div class="hint">
            - 排行榜是「全球榜」，會看到網路上其他玩家分數。<br/>
            - 左上角是你自己裝置的最高分。
          </div>
        </div>

        <div id="viewBoard" style="display:none;">
          <!-- ✅ GAME OVER 大字顯示 -->
          <div id="gameOverPanel" style="display:none; margin-bottom:12px;">
            <div id="goTitle" style="
              font-weight:1000;
              font-size:34px;
              letter-spacing:1px;
              text-align:center;
              margin:2px 0 6px;
            ">結束了我的朋友</div>

            <div style="
              text-align:center;
              font-weight:900;
              font-size:14px;
              color:rgba(255,255,255,0.72);
              margin-bottom:6px;
            ">本局得分</div>

            <div id="goScore" style="
              text-align:center;
              font-weight:1000;
              font-size:44px;
              line-height:1.05;
            ">0分</div>

            <!-- ✅ 本局最高 COMBO（新增，不影響既有效果） -->
            <div style="
              text-align:center;
              font-weight:900;
              font-size:14px;
              color:rgba(255,255,255,0.72);
              margin-top:10px;
              margin-bottom:6px;
            ">本局最高 COMBO</div>

            <div id="goCombo" style="
              text-align:center;
              font-weight:1000;
              font-size:32px;
              line-height:1.05;
            ">x0</div>
          </div>

          <div class="actions" style="margin-top:0;">
            <button id="btnBackToLogin" class="btn btnGhost">回到首頁</button>
            <button id="btnRefreshBoard" class="btn btnGhost">刷新</button>
            <button id="btnPlayAgain" class="btn btnPrimary">再玩一局</button>
          </div>

          <div class="board" style="margin-top:12px;">
            <div class="boardHeader">
              <div>RANK</div>
              <div>NAME</div>
              <div class="right">SCORE</div>
              <div class="right">H-COMBO</div>
            </div>

            <!-- ✅ 前 6 名 -->
            <div id="boardList"></div>

            <!-- ✅ 後 6 名折疊清單（新增，不更動原本列的呈現） -->
            <details id="moreBoard" style="border-top:1px solid rgba(255,255,255,0.06); display:none;">
              <summary style="
                padding:10px 12px;
                cursor:pointer;
                user-select:none;
                color:rgba(255,255,255,0.75);
                font-weight:900;
                list-style:none;
              ">
                顯示第 7–12 名
                <span style="float:right; color:rgba(255,255,255,0.5); font-weight:800;">(點我展開)</span>
              </summary>
              <div id="boardListMore"></div>
            </details>
          </div>

          <div class="smallNote" id="boardStatus"></div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
  /* =========================================================
   *  Firebase（Firestore 全球榜）
   * ========================================================= */
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import {
    getFirestore, doc, setDoc, getDoc, collection,
    query, orderBy, limit, getDocs, serverTimestamp,
    where, getCountFromServer
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDgLjm7EvbkziBiatT0UN-OMyGp9WVzbdQ",
    authDomain: "game-cancelblock.firebaseapp.com",
    projectId: "game-cancelblock",
    storageBucket: "game-cancelblock.firebasestorage.app",
    messagingSenderId: "734625700314",
    appId: "1:734625700314:web:b65e6505a37f9fa226c8e3",
    measurementId: "G-E3N6NP4J9K"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const LEADERBOARD_COL = "leaderboard_v1";

  // ✅ Promise 超時保護（避免 game over 卡死）
  function withTimeout(promise, ms, msg = "timeout") {
    let t;
    const timeout = new Promise((_, rej) => {
      t = setTimeout(() => rej(new Error(msg)), ms);
    });
    return Promise.race([promise, timeout]).finally(() => clearTimeout(t));
  }

  // 每台裝置固定一個 uid（避免同名互相覆蓋）
  const LS_UID_KEY = "blockDeviceUidV1";
  function getOrCreateDeviceUid() {
    let uid = localStorage.getItem(LS_UID_KEY);
    if (!uid) {
      uid = (crypto?.randomUUID?.() || ("uid_" + Math.random().toString(16).slice(2) + Date.now()));
      localStorage.setItem(LS_UID_KEY, uid);
    }
    return uid;
  }
  const deviceUid = getOrCreateDeviceUid();

  // ✅ 上傳：score / bestCombo 都採「只增不減」
  async function remoteUpsertBest(name, score, bestCombo, hCombo) {
    name = (name || "").trim().slice(0, 16);
    if (!name) return;

    const ref = doc(db, LEADERBOARD_COL, deviceUid);
    const snap = await getDoc(ref);

    const prevScore = snap.exists() ? Number(snap.data().score || 0) : 0;
    const prevBestCombo = snap.exists() ? Number(snap.data().bestCombo || 0) : 0;
    const prevHCombo = snap.exists() ? Number(snap.data().hCombo || 0) : 0;

    const next = {
      uid: deviceUid,
      name,
      updatedAt: serverTimestamp()
    };

    // ✅ 1) 歷史最高 combo：只增不減（跟分數無關）
    if (typeof bestCombo === "number" && bestCombo > prevBestCombo) {
      next.bestCombo = bestCombo;
    }

    // ✅ 2) 最高分：只在更高分才更新 score
    //    並且讓 hCombo 跟著「最高分那局」一起更新
    if (typeof score === "number" && score > prevScore) {
      next.score = score;

      // 這局的最高 combo，跟著最高分一起紀錄
      if (typeof hCombo === "number") {
        next.hCombo = hCombo;
      } else {
        next.hCombo = prevHCombo; // 保底
      }
    } else {
      // 分數沒破紀錄：hCombo 不要動（避免低分局覆蓋）
      // next.hCombo 不填
    }

    await setDoc(ref, next, { merge: true });
  }


  async function remoteFetchTop(topN = 12) {
    const q = query(collection(db, LEADERBOARD_COL), orderBy("score", "desc"), limit(topN));
    const snap = await getDocs(q);
    return snap.docs.map(d => d.data());
  }

  async function remoteFetchMe() {
    const ref = doc(db, LEADERBOARD_COL, deviceUid);
    const snap = await getDoc(ref);
    return snap.exists() ? snap.data() : null;
  }

  async function remoteComputeMyRank(myScore) {
    if (typeof myScore !== "number") return null;
    const col = collection(db, LEADERBOARD_COL);
    const q = query(col, where("score", ">", myScore));
    const agg = await getCountFromServer(q);
    const higher = agg.data().count || 0;
    return higher + 1;
  }

  /* =========================================================
   *  Overlay UI
   * ========================================================= */
  const LS_NAME_KEY = "blockPlayerName";
  function getPlayerName() { return (localStorage.getItem(LS_NAME_KEY) || "").trim(); }
  function setPlayerName(name) { localStorage.setItem(LS_NAME_KEY, name.trim()); }

  const overlay = document.getElementById("overlay");
  const tabLogin = document.getElementById("tabLogin");
  const tabBoard = document.getElementById("tabBoard");
  const viewLogin = document.getElementById("viewLogin");
  const viewBoard = document.getElementById("viewBoard");
  const nameInput = document.getElementById("nameInput");
  const btnStart = document.getElementById("btnStart");
  const btnToBoard = document.getElementById("btnToBoard");
  const btnBackToLogin = document.getElementById("btnBackToLogin");
  const btnRefreshBoard = document.getElementById("btnRefreshBoard");
  const btnPlayAgain = document.getElementById("btnPlayAgain");
  const playerMini = document.getElementById("playerMini");
  const boardList = document.getElementById("boardList");
  const boardStatus = document.getElementById("boardStatus");

  // ✅ 新增：折疊榜單容器
  const boardListMore = document.getElementById("boardListMore");
  const moreBoard = document.getElementById("moreBoard");

  // ✅ GAME OVER elements
  const gameOverPanel = document.getElementById("gameOverPanel");
  const goScore = document.getElementById("goScore");
  const goCombo = document.getElementById("goCombo"); // ✅ 新增

  function showOverlay() { overlay.style.display = "flex"; }
  function hideOverlay() { overlay.style.display = "none"; }
  function syncPlayerMini() {
    const n = getPlayerName();
    playerMini.textContent = n ? `玩家：${n}` : "";
  }

  function switchTab(which) {
    const isLogin = which === "login";
    tabLogin.classList.toggle("active", isLogin);
    tabBoard.classList.toggle("active", !isLogin);
    viewLogin.style.display = isLogin ? "block" : "none";
    viewBoard.style.display = isLogin ? "none" : "block";
    if (!isLogin) refreshBoardUI();
  }

  tabLogin.onclick = () => switchTab("login");
  tabBoard.onclick = () => switchTab("board");
  btnToBoard.onclick = () => switchTab("board");

  btnBackToLogin.onclick = () => {
    gameOverPanel.style.display = "none";
    showOverlay();
    switchTab("login");
    nameInput.focus();
  };

  btnRefreshBoard.onclick = () => refreshBoardUI();

  btnPlayAgain.onclick = () => {
    hideOverlay();
    gameOverPanel.style.display = "none"; // ✅ 收起 GAME OVER
    gameOver = false;
    resetGame();
  };

  btnStart.onclick = () => {
    const name = nameInput.value.trim();
    if (!name) {
      nameInput.focus();
      nameInput.placeholder = "請先輸入暱稱！";
      return;
    }
    setPlayerName(name);
    syncPlayerMini();
    hideOverlay();
    resetGame();
  };
  nameInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") btnStart.click();
  });

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"
    }[m]));
  }

  function renderRow(rank, name, score, hCombo, isMe=false) {
    let pillBg = "rgba(255,255,255,0.10)";
    let pillBd = "rgba(255,255,255,0.10)";
    if (rank === 1) { pillBg = "rgba(255,215,0,0.22)"; pillBd = "rgba(255,215,0,0.35)"; }
    else if (rank === 2) { pillBg = "rgba(200,200,200,0.18)"; pillBd = "rgba(200,200,200,0.28)"; }
    else if (rank === 3) { pillBg = "rgba(205,127,50,0.18)"; pillBd = "rgba(205,127,50,0.28)"; }

    const div = document.createElement("div");
    div.className = "boardRow" + (isMe ? " meRow" : "");

    const s = Number(score || 0);
    const hc = Number(hCombo || 0);

    div.innerHTML = `
      <div class="rankPill" style="background:${pillBg};border-color:${pillBd}">${rank}</div>
      <div class="nameCell">
  ${escapeHtml(name || "-")}${isMe ? ' <span class="muted">(你)</span>' : ""}
      </div>

      <div class="right">${s.toLocaleString()}</div>
      <div class="right">x${hc}</div>
    `;
    return div;
  }



  async function refreshBoardUI() {
    boardStatus.textContent = "讀取中...";
    boardList.innerHTML = "";
    boardListMore.innerHTML = "";
    moreBoard.open = false;
    moreBoard.style.display = "none";

    try {
      // ✅ 改為抓 12 筆：前 6 顯示，後 6 摺疊
      const top = await withTimeout(remoteFetchTop(12), 3500, "Firestore read timeout");

      if (!top.length) {
        const empty = document.createElement("div");
        empty.className = "boardRow";
        empty.innerHTML = `
          <div class="rankPill">-</div>
          <div class="muted">目前沒有紀錄</div>
          <div class="right muted">-</div>
          <div class="right muted">-</div>
        `;

        boardList.appendChild(empty);
        boardStatus.textContent = "目前榜單為空。先玩一局產生資料～";
        return;
      }

      top.forEach((item, i) => {
        const isMe = (item.uid === deviceUid);
        const row = renderRow(i+1, item.name, item.score, item.hCombo, isMe);

        if (i < 6) boardList.appendChild(row);
        else boardListMore.appendChild(row);
      });


      if (top.length > 6) {
        moreBoard.style.display = "block";
        const summarySpan = moreBoard.querySelector("summary span");
        if (summarySpan) summarySpan.textContent = `(點我展開，共 ${top.length - 6} 筆)`;
      }

      const me = await withTimeout(remoteFetchMe(), 3500, "Firestore me timeout");
      if (me && typeof me.score === "number") {
        const inTop = top.some(x => x.uid === deviceUid);
        if (!inTop) {
          const sep = document.createElement("div");
          sep.className = "sep";
          // 分隔線插在「前 6」與折疊區之間會怪，所以插在前 6 的尾端
          boardList.appendChild(sep);

          const myRank = await withTimeout(remoteComputeMyRank(me.score), 3500, "Firestore rank timeout");
          if (myRank != null) {
            boardList.appendChild(renderRow(myRank, me.name, me.score, me.hCombo, true));

          }
        }
      }

      // ✅ 顯示「使用者最高 COMBO」
      const me2 = await withTimeout(remoteFetchMe(), 3500, "Firestore me timeout 2");
      if (me2 && typeof me2.bestCombo === "number") {
        boardStatus.textContent = `你的最高 COMBO：x${me2.bestCombo}`;
      } else {
        boardStatus.textContent = `你的最高 COMBO：x${bestComboLocal}`;
      }
    } catch (e) {
      console.error("Leaderboard error:", e);
      boardStatus.textContent = "排行榜讀取失敗。請開 Console 看錯誤訊息。";
      const err = document.createElement("div");
      err.className = "boardRow";
      err.innerHTML = `
        <div class="rankPill">!</div>
        <div class="muted">無法載入全球榜</div>
        <div class="right muted">-</div>
        <div class="right muted">-</div>
      `;
      boardList.appendChild(err);
    }
  }

  /* =========================================================
   *  遊戲本體（吸附/回彈/紅色提示/特效/Combo）
   * ========================================================= */
  const GRID_SIZE = 9;
  const CELL_SIZE = 55;

  const SIDEBAR_W = 250;
  const BOTTOMBAR_H = 220;

  const DRAG_GAIN = 1.6;
  const MAGNET_SEARCH_RADIUS = 2;

  const PREVIEW_ALPHA_OK = 0.28;
  const PREVIEW_ALPHA_BAD = 0.14;

  const DRAG_LIFT = CELL_SIZE * 0.9;

  const FAIL_SHAKE = 14;
  const FAIL_VIBRATION_PATTERN = [25, 30, 25];

  let failOverlayLife = 0;

  let bounceLife = 0;
  let bounceFromX = 0, bounceFromY = 0;
  let bounceToX = 0, bounceToY = 0;
  let bounceShape = null;
  let bounceTheme = null;

  let particles = [];
  let lineFlashes = [];
  let haloAngle = 0;           // 畫面用角度（弧度）
  let haloSpeed = 0.018;       // 轉速（可調：越大轉越快）
  let haloPulse = 0;           // 成功放置時加強一下光暈（可選）
  let haloDashOffset = 0;
  // ✅ 成功放置粒子（新增，和消除粒子分開）
  let placeParticles = [];
  let placeRings = [];

  // === Clear animation state ===
  // grid cell: 0 empty, 1 filled, 2 clearing (fade-out)
  let clearingCells = [];                 // array of {r,c,life}
  let clearingMap = new Map();            // key "r,c" -> {life}

  let dragStartPX = 0, dragStartPY = 0;
  let dragStartAX = 0, dragStartAY = 0;
  let dragNowAX = 0, dragNowAY = 0;

  function isMobileLayout() { return window.matchMedia("(max-width: 600px)").matches; }

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  const restartBtn = document.getElementById('restartBtn');

  const comboBadge = document.getElementById('comboBadge');
  const comboCountEl = document.getElementById('comboCount');

  const THEMES = [
    { main:'#4A90E2', dark:'#21508A', light:'#A4C8F5' },
    { main:'#50E3C2', dark:'#2A8F79', light:'#B2F2E5' },
    { main:'#F5A623', dark:'#A36B0D', light:'#FCD9A1' }
  ];

  const SHAPE_DEFS = [
    { shape: [[0,0],[0,1]], weight: 10 },
    { shape: [[0,0],[1,0]], weight: 10 },
    { shape: [[0,0],[0,1],[1,0],[1,1]], weight: 10 },
    { shape: [[0,0],[0,1],[0,2]], weight: 10 },
    { shape: [[0,0],[1,0],[2,0]], weight: 10 },
    { shape: [[0,0],[1,0],[1,1]], weight: 10 },
    { shape: [[0,0]], weight: 10 },
    { shape: [[0,0],[0,1],[0,2],[0,3]], weight: 10 },
    { shape: [[0,0],[1,0],[2,0],[3,0]], weight: 10 },
    { shape: [[0,0],[1,0],[1,1],[2,1]], weight: 10 },
    { shape: [[0,1],[0,2],[1,0],[1,1]], weight: 10 },
    { shape: [[0,1],[1,0],[1,1],[1,2]], weight: 10 },
    { shape: [[0,0],[1,0],[2,0],[2,1]], weight: 10 },
    { shape: [[0,0],[0,1],[0,2],[1,0],[2,0]], weight: 3 },
    { shape: [[0,1],[1,0],[1,1],[1,2],[2,1]], weight: 3 },
    { shape: [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]], weight: 3 }
  ];

  let currentTheme;
  let grid, hand, score, highScore;

  let draggingIdx = null;
  let pointerX = 0, pointerY = 0;
  let gameOver = false;

  let shakeIntensity = 0;
  let currentComboCount = 0;

  // ✅ 新增：本局最高 combo + 本機歷史最高 combo（不影響右上 combo 顯示與消除效果）
  let maxComboThisRun = 0;
  let bestComboLocal = 0;
  const LS_BEST_COMBO_KEY = "blockBestComboV1";

  let floatingTexts = [];
  let layout = null;

  const COMBO_TEXT = {
    good: "晏羽說不錯",
    nice: "晏羽說漂亮",
    great: "晏羽說超讚",
    perfect: "晏羽說完美",
    godlike: "晏羽說神操作"
  };

  function getComboTier(combo) {
    if (combo >= 6) return { name: COMBO_TEXT.godlike, color:"#FFEA00", glow:"rgba(255,234,0,0.75)", border:"rgba(255,234,0,0.55)" };
    if (combo >= 4) return { name: COMBO_TEXT.perfect, color:"#FFD700", glow:"rgba(255,215,0,0.65)", border:"rgba(255,215,0,0.45)" };
    if (combo >= 3) return { name: COMBO_TEXT.great,   color:"#7CFCFF", glow:"rgba(124,252,255,0.55)", border:"rgba(124,252,255,0.40)" };
    if (combo >= 2) return { name: COMBO_TEXT.nice,    color:"#B7FF6A", glow:"rgba(183,255,106,0.45)", border:"rgba(183,255,106,0.35)" };
    return             { name: COMBO_TEXT.good,    color:"#FFFFFF", glow:"rgba(255,255,255,0.30)", border:"rgba(255,255,255,0.20)" };
  }

  // ✅ COMBO UI 常駐，無 combo 顯示 x0
  function updateComboUI() {
    comboBadge.style.display = "inline-flex";
    comboBadge.style.alignItems = "center";

    const shown = Math.max(0, currentComboCount);
    comboCountEl.innerText = "x" + shown;

    if (currentComboCount > 0) {
      const t2 = getComboTier(currentComboCount);
      comboBadge.style.borderColor = t2.border;
      comboBadge.style.boxShadow = `0 0 18px ${t2.glow}`;
      comboBadge.style.opacity = "1";
    } else {
      comboBadge.style.borderColor = "rgba(255,255,255,0.18)";
      comboBadge.style.boxShadow = "none";
      comboBadge.style.opacity = "0.55";
    }
  }

  function computeLayout() {
    const mobile = isMobileLayout();
    if (mobile) {
      const rawW = GRID_SIZE * CELL_SIZE;
      const rawH = GRID_SIZE * CELL_SIZE + BOTTOMBAR_H;

      const handX = 0;
      const handY = GRID_SIZE * CELL_SIZE;
      const handW = rawW;
      const handH = BOTTOMBAR_H;

      const padX = 20;
      const padY = 25;
      const slotW = (handW - padX * 2) / 3;
      const slotH = handH - padY * 2;

      const slots = [0,1,2].map(i => ({
        x: handX + padX + i * slotW,
        y: handY + padY,
        w: slotW,
        h: slotH
      }));

      return {
        mode: "mobile",
        rawW, rawH,
        gridX: 0, gridY: 0,
        hand: { x: handX, y: handY, w: handW, h: handH, slots },
        handBlock: 24,
        handGap: 4
      };
    } else {
      const rawW = GRID_SIZE * CELL_SIZE + SIDEBAR_W;
      const rawH = GRID_SIZE * CELL_SIZE;

      const handX = GRID_SIZE * CELL_SIZE;
      const handY = 0;
      const handW = SIDEBAR_W;
      const handH = rawH;

      const slots = [0,1,2].map(i => ({
        x: handX + 20,
        y: 40 + i * 150,
        w: handW - 40,
        h: 120
      }));

      return {
        mode: "desktop",
        rawW, rawH,
        gridX: 0, gridY: 0,
        hand: { x: handX, y: handY, w: handW, h: handH, slots },
        handBlock: 20,
        handGap: 2
      };
    }
  }

  function applyLayout(newLayout) {
    layout = newLayout;
    canvas.width = layout.rawW;
    canvas.height = layout.rawH;
  }

  function pathRoundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function drawBlock(x, y, size, r, theme, alpha = 1.0) {
    ctx.save();
    ctx.globalAlpha = alpha;
    pathRoundedRect(x, y, size, size, r);
    const g = ctx.createLinearGradient(x, y, x + size, y + size);
    g.addColorStop(0, theme.light);
    g.addColorStop(1, theme.dark);
    ctx.fillStyle = g;
    ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,0.2)";
    ctx.beginPath();
    ctx.arc(x + size*0.3, y + size*0.3, size*0.15, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawTextWithStroke(txt, x, y, size, color, stroke = "rgba(0,0,0,0.55)", align = "center") {
    ctx.save();
    ctx.font = `900 ${size}px Arial`;
    ctx.textAlign = align;
    ctx.textBaseline = "middle";
    ctx.lineWidth = Math.max(3, size * 0.12);
    ctx.strokeStyle = stroke;
    ctx.fillStyle = color;
    ctx.strokeText(txt, x, y);
    ctx.fillText(txt, x, y);
    ctx.restore();
  }

  function drawRotatingHalo() {
    const x = layout.gridX;
    const y = layout.gridY;
    const w = GRID_SIZE * CELL_SIZE;
    const h = GRID_SIZE * CELL_SIZE;

    // 外框往外擴的距離、圓角、線寬（可調）
    const pad = 2;
    const r = 5;
    const baseLW = 1;   // 底光線寬
    const runLW  = 3;   // 跑光線寬（略粗）

    // 跑光速度（越大越快）
    const speed = 1.5;

    // 用時間驅動（不依賴 haloAngle 也可以）
    const t = performance.now() / 1000;

    // 近似外框周長（圓角矩形）
    const innerW = w + pad * 2;
    const innerH = h + pad * 2;
    const perim = 2 * (innerW + innerH - 4 * r) + 2 * Math.PI * r;

    // 主亮點長度：佔整圈比例（越大亮點越長）
    const segLen = perim * 1;        // 22% 周長
    const gapLen = perim - segLen;

    // 跑光位置（沿路徑前進）
    const offset = -(t * speed * 120);  // 120 只是縮放手感，可調

    ctx.save();

    // 1) 先畫「整圈淡淡的霓虹底光」：四邊永遠看得到
    ctx.globalAlpha = 15;
    ctx.lineWidth = baseLW;
    ctx.strokeStyle = "rgba(255,255,255,0.16)";
    ctx.shadowColor = "rgba(255,215,0,0.22)";
    ctx.shadowBlur = 15;

    ctx.beginPath();
    pathRoundedRect(x - pad, y - pad, w + pad * 2, h + pad * 2, r);
    ctx.stroke();

    // 2) 再畫「主跑光」：用 dash + dashOffset 讓亮段沿著邊框跑
    ctx.lineWidth = runLW;
    ctx.setLineDash([segLen, gapLen]);
    ctx.lineDashOffset = offset;

    // 亮段本體顏色（可以換成你想要的霓虹色）
    ctx.strokeStyle = "#FFFFFF";
    ctx.shadowColor = "#FFFFFF";
    ctx.shadowBlur = 15;

    ctx.beginPath();
    pathRoundedRect(x - pad, y - pad, w + pad * 2, h + pad * 2, r);
    ctx.stroke();

    // 3) 可選：再疊一層更亮的「核心」讓主亮點更像 Apple Watch
    ctx.lineWidth = 2.5;
    ctx.setLineDash([segLen * 0.55, gapLen + segLen * 0.45]);
    ctx.lineDashOffset = offset - 18; // 稍微錯開一點更有層次
    ctx.strokeStyle = "rgba(255,255,255,0.80)";
    ctx.shadowColor = "rgba(255,255,255,0.65)";
    ctx.shadowBlur = 10;

    ctx.beginPath();
    pathRoundedRect(x - pad, y - pad, w + pad * 2, h + pad * 2, r);
    ctx.stroke();

    // 清掉 dash，避免影響其他畫圖
    ctx.setLineDash([]);
    ctx.restore();
  }



  function resetGame() {
    applyLayout(computeLayout());

    currentTheme = THEMES[Math.floor(Math.random() * THEMES.length)];

    grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
    score = 0;
    highScore = Number(localStorage.getItem('blockHighScore') || 0);

    gameOver = false;
    shakeIntensity = 0;
    currentComboCount = 0;
    floatingTexts = [];
    particles = [];
    lineFlashes = [];
    placeParticles = [];
    placeRings = [];
    haloPulse = 0;
    failOverlayLife = 0;
    bounceLife = 0;

    // ✅ combo 最高紀錄（新增）
    maxComboThisRun = 0;
    bestComboLocal = Number(localStorage.getItem(LS_BEST_COMBO_KEY) || 0);

    // clear-anim state
    clearingCells = [];
    clearingMap.clear();

    document.getElementById('scoreDisplay').innerText = "0";
    document.getElementById('highScore').innerText = String(highScore);
    restartBtn.style.display = "none";

    updateComboUI();
    refreshHand();
  }

  function refreshHand() {
    hand = [];
    for (let i = 0; i < 3; i++) {
      const totalW = SHAPE_DEFS.reduce((s, x) => s + x.weight, 0);
      let rand = Math.random() * totalW;
      let chosen = SHAPE_DEFS[0].shape;
      for (const def of SHAPE_DEFS) {
        if (rand < def.weight) { chosen = def.shape; break; }
        rand -= def.weight;
      }
      hand.push(chosen);
    }
  }

  // ✅ clearing(2) 也視為佔用
  function canPlace(shape, r, c) {
    if (!shape || r < 0 || c < 0) return false;
    for (let i = 0; i < shape.length; i++) {
      const nr = r + shape[i][0];
      const nc = c + shape[i][1];
      if (nr >= GRID_SIZE || nc >= GRID_SIZE || grid[nr][nc] !== 0) return false;
    }
    return true;
  }

  function spawnClearParticles(cells) {
    for (const {r, c} of cells) {
      const cx = layout.gridX + c * CELL_SIZE + CELL_SIZE / 2;
      const cy = layout.gridY + r * CELL_SIZE + CELL_SIZE / 2;

      const n = 10 + Math.floor(Math.random() * 6);
      for (let i = 0; i < n; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = 2 + Math.random() * 6;
        particles.push({
          x: cx, y: cy,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd - 1.5,
          life: 1,
          size: 2 + Math.random() * 3
        });
      }
    }
  }

    // ✅ 成功放置：粒子 + 擴散圈 + 小浮字（新增）
  function spawnPlaceParticles(cells) {
    // 每格少量粒子
    for (const {r, c} of cells) {
      const cx = layout.gridX + c * CELL_SIZE + CELL_SIZE / 2;
      const cy = layout.gridY + r * CELL_SIZE + CELL_SIZE / 2;

      const n = 4 + Math.floor(Math.random() * 4); // 4~7
      for (let i = 0; i < n; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = 0.8 + Math.random() * 2.2;
        placeParticles.push({
          x: cx, y: cy,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd - 0.6,
          life: 1,
          size: 1.2 + Math.random() * 2.0
        });
      }
    }

    // 中心擴散圈
    placeRings.push({
      x: layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
      y: layout.gridY + (GRID_SIZE * CELL_SIZE) / 2,
      r: 14,
      life: 1
    });

    // 外圈 halo 稍微加強一下
    haloPulse = Math.min(1, haloPulse + 0.65);

    // 短命回饋文字（不動你 combo 的浮字）
    if (Math.random() < 0.15) {
      floatingTexts.push({
        lines: [{ txt: "放置成功！", color: "#B7FF6A", sizeMul: 1.0 }],
        x: layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
        y: layout.gridY + (GRID_SIZE * CELL_SIZE) / 2 + 40,
        life: 1,
        vy: 0.8,
        size: 22,
        align: "center",
        stroke: "rgba(0,0,0,0.65)"
      });
    }
  }

  function updateAndDrawPlaceParticles() {
    for (let i = placeParticles.length - 1; i >= 0; i--) {
      const p = placeParticles[i];
      p.life -= 0.05;
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.10;
      p.vx *= 0.96;
      p.vy *= 0.96;

      if (p.life <= 0) { placeParticles.splice(i, 1); continue; }

      ctx.save();
      ctx.globalAlpha = Math.max(0, p.life) * 0.85;
      ctx.fillStyle = "#FFFFFF";
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function updateAndDrawPlaceRings() {
    for (let i = placeRings.length - 1; i >= 0; i--) {
      const r = placeRings[i];
      r.life -= 0.06;
      r.r += 4.2;

      if (r.life <= 0) { placeRings.splice(i, 1); continue; }

      ctx.save();
      ctx.globalAlpha = Math.max(0, r.life) * 0.25;
      ctx.strokeStyle = "rgba(255,255,255,1)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function updateAndDrawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.life -= 0.03;
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.2;
      p.vx *= 0.98;
      p.vy *= 0.98;

      if (p.life <= 0) { particles.splice(i, 1); continue; }

      ctx.save();
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = "rgba(255, 215, 0, 1)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.beginPath();
      ctx.arc(p.x - 1, p.y - 1, p.size * 0.55, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function spawnLineFlash(rows, cols) {
    for (const r of rows) lineFlashes.push({ type:'row', idx:r, life:1 });
    for (const c of cols) lineFlashes.push({ type:'col', idx:c, life:1 });
  }

  function updateAndDrawLineFlashes() {
    for (let i = lineFlashes.length - 1; i >= 0; i--) {
      const f = lineFlashes[i];
      f.life -= 0.06;
      if (f.life <= 0) { lineFlashes.splice(i, 1); continue; }

      ctx.save();
      ctx.globalAlpha = Math.max(0, f.life);
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      if (f.type === 'row') {
        const y = layout.gridY + f.idx * CELL_SIZE;
        ctx.fillRect(layout.gridX, y, GRID_SIZE * CELL_SIZE, CELL_SIZE);
      } else {
        const x = layout.gridX + f.idx * CELL_SIZE;
        ctx.fillRect(x, layout.gridY, CELL_SIZE, GRID_SIZE * CELL_SIZE);
      }
      ctx.restore();
    }
  }

  function pushFloatingBreakdown(x, y, tier, base, multi, baseTotal, multiplier, gain) {
    const lines = [];
    lines.push({ txt: tier.name, color: tier.color, sizeMul: 1.25 });

    lines.push({ txt: `+${gain} TOTAL`, color: "#FFD700", sizeMul: 1.05 });

    lines.push({ txt: `BaseTotal ${baseTotal}`, color: "rgba(255,255,255,0.95)", sizeMul: 0.85 });
    lines.push({ txt: `= (Base ${base} + Multi ${multi})`, color: "rgba(255,255,255,0.70)", sizeMul: 0.75 });

    lines.push({ txt: `x${multiplier} Combo Multiplier`, color: "rgba(183,255,106,0.95)", sizeMul: 0.85 });

    floatingTexts.push({
      lines,
      x, y,
      life: 1,
      vy: 1.25,
      size: 28,
      align: "center",
      stroke: "rgba(0,0,0,0.65)"
    });
  }

  function updateAndDrawFloatingTexts() {
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      const t = floatingTexts[i];
      t.y -= t.vy;
      t.life -= 0.02;

      const alpha = Math.max(0, t.life);
      if (alpha <= 0) { floatingTexts.splice(i, 1); continue; }

      let y = t.y;
      for (let j = 0; j < t.lines.length; j++) {
        const line = t.lines[j];
        const sz = t.size * (line.sizeMul ?? 1);
        ctx.save();
        ctx.globalAlpha = alpha;
        drawTextWithStroke(line.txt, t.x, y, sz, line.color, t.stroke, t.align);
        ctx.restore();
        y += sz * 1.05;
      }
    }
  }

  function calcGain(lines, comboCount) {
    const base = lines * 10;
    const multiLineBonus = Math.max(0, lines - 1) * 16;
    const baseTotal = base + multiLineBonus;

    const multiplier = Math.max(1, comboCount);
    const gain = baseTotal * multiplier;

    return { base, multiLineBonus, baseTotal, multiplier, gain };
  }

  function startClearingCells(clearedCells) {
    for (const { r, c } of clearedCells) {
      const key = `${r},${c}`;

      // ✅ 只要不是空格，就允許進 clearing（1 或 2 都可以）
      if (grid[r][c] !== 0) {
        grid[r][c] = 2;

        if (!clearingMap.has(key)) {
          const obj = { r, c, life: 1 };
          clearingCells.push(obj);
          clearingMap.set(key, obj);
        } else {
          clearingMap.get(key).life = 1;
        }
      }
    }
  }

  function updateClearingCells() {
    for (let i = clearingCells.length - 1; i >= 0; i--) {
      const cc = clearingCells[i];
      cc.life -= 0.08;
      if (cc.life <= 0) {
        if (grid[cc.r][cc.c] === 2) grid[cc.r][cc.c] = 0;
        clearingMap.delete(`${cc.r},${cc.c}`);
        clearingCells.splice(i, 1);
      }
    }
  }

  function checkAndClear() {
    const rs = [], cs = [];

    for (let r = 0; r < GRID_SIZE; r++) {
      if (grid[r].every(v => v !== 0)) rs.push(r);
    }

    for (let c = 0; c < GRID_SIZE; c++) {
      let full = true;
      for (let r = 0; r < GRID_SIZE; r++) {
        if (grid[r][c] === 0) { full = false; break; }
      }
      if (full) cs.push(c);
    }

    const lines = rs.length + cs.length;
    if (lines <= 0) return false;

    // ✅ 清除抖動
    shakeIntensity = Math.max(shakeIntensity, lines * 8);

    // ✅ combo++
    currentComboCount++;
    // ✅ 新增：本局最高 combo 追蹤（不影響右上 combo 呈現）
    maxComboThisRun = Math.max(maxComboThisRun, currentComboCount);

    updateComboUI();

    // ✅ 乘數計分
    const { base, multiLineBonus, baseTotal, multiplier, gain } = calcGain(lines, currentComboCount);
    score += gain;
    document.getElementById('scoreDisplay').innerText = String(score);

    if (score > highScore) {
      highScore = score;
      localStorage.setItem('blockHighScore', String(score));
      document.getElementById('highScore').innerText = String(score);
    }

    // ✅ 浮字
    const tier = getComboTier(currentComboCount);
    pushFloatingBreakdown(
      layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
      layout.gridY + (GRID_SIZE * CELL_SIZE) / 2 - 60,
      tier, base, multiLineBonus, baseTotal, multiplier, gain
    );

    // ✅ 清除格子集合（rows+cols 去重）
    const clearedSet = new Set();
    for (const r of rs) for (let c = 0; c < GRID_SIZE; c++) clearedSet.add(`${r},${c}`);
    for (const c of cs) for (let r = 0; r < GRID_SIZE; r++) clearedSet.add(`${r},${c}`);

    const clearedCells = Array.from(clearedSet).map(s => {
      const [r, c] = s.split(',').map(Number);
      return { r, c };
    });

    // ✅ 閃光 + 粒子
    spawnLineFlash(rs, cs);
    spawnClearParticles(clearedCells);

    // ✅ 淡出清除
    startClearingCells(clearedCells);

    return true;
  }

  function getCanvasPosFromClient(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / (rect.width || 1));
    const y = (clientY - rect.top) * (canvas.height / (rect.height || 1));
    return { x, y };
  }

  function pickHandIndex(pos) {
    const { slots } = layout.hand;
    for (let i = 0; i < slots.length; i++) {
      const s = slots[i];
      if (pos.x >= s.x && pos.x <= s.x + s.w && pos.y >= s.y && pos.y <= s.y + s.h) {
        if (hand[i]) return i;
      }
    }
    return null;
  }

  function shapeBoundingBox(shape) {
    let minR = Infinity, minC = Infinity, maxR = -Infinity, maxC = -Infinity;
    for (const [r,c] of shape) {
      minR = Math.min(minR, r); minC = Math.min(minC, c);
      maxR = Math.max(maxR, r); maxC = Math.max(maxC, c);
    }
    return { minR, minC, maxR, maxC, w: maxC - minC + 1, h: maxR - minR + 1 };
  }

  function getHandSlotHomeAnchor(idx, shape) {
    const slot = layout.hand.slots[idx];
    const bb = shapeBoundingBox(shape);
    const block = layout.handBlock;
    const gap = layout.handGap;

    const shapeW = bb.w * (block + gap) - gap;
    const shapeH = bb.h * (block + gap) - gap;

    const startX = slot.x + (slot.w - shapeW) / 2;
    const startY = slot.y + (slot.h - shapeH) / 2;

    const anchorCenterX = startX + (0 - bb.minC) * (block + gap) + block / 2;
    const anchorCenterY = startY + (0 - bb.minR) * (block + gap) + block / 2;

    return { x: anchorCenterX - CELL_SIZE * 0.5, y: anchorCenterY - CELL_SIZE * 0.5 };
  }

  function findBestMagnet(shape, anchorX, anchorY) {
    const gx = (anchorX - layout.gridX) / CELL_SIZE;
    const gy = (anchorY - layout.gridY) / CELL_SIZE;

    const baseC = Math.round(gx);
    const baseR = Math.round(gy);

    let best = null;

    for (let dr = -MAGNET_SEARCH_RADIUS; dr <= MAGNET_SEARCH_RADIUS; dr++) {
      for (let dc = -MAGNET_SEARCH_RADIUS; dc <= MAGNET_SEARCH_RADIUS; dc++) {
        const r = baseR + dr;
        const c = baseC + dc;
        if (r < 0 || c < 0 || r >= GRID_SIZE || c >= GRID_SIZE) continue;
        if (!canPlace(shape, r, c)) continue;

        const snappedX = layout.gridX + c * CELL_SIZE;
        const snappedY = layout.gridY + r * CELL_SIZE;

        const dx = (anchorX - snappedX) / CELL_SIZE;
        const dy = (anchorY - snappedY) / CELL_SIZE;
        const distNorm = Math.hypot(dx, dy);

        if (best === null || distNorm < best.distNorm) best = { r, c, snappedX, snappedY, distNorm };
      }
    }

    if (!best) return { can:false };
    return { ...best, can:true };
  }

  function failFeedback() {
    shakeIntensity = Math.max(shakeIntensity, FAIL_SHAKE);
    failOverlayLife = 1;

    floatingTexts.push({
      lines: [{ txt: "放不下！", color: "#FF6A6A", sizeMul: 1.1 }],
      x: layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
      y: layout.gridY + (GRID_SIZE * CELL_SIZE) / 2 - 30,
      life: 1,
      vy: 1.1,
      size: 28,
      align: "center",
      stroke: "rgba(0,0,0,0.70)"
    });

    if (navigator.vibrate) {
      try { navigator.vibrate(FAIL_VIBRATION_PATTERN); } catch (_) {}
    }
  }

  function startBounceBack(idx, shape, fromAnchorX, fromAnchorY) {
    bounceLife = 1;
    bounceShape = shape;
    bounceTheme = currentTheme;

    bounceFromX = fromAnchorX;
    bounceFromY = fromAnchorY;

    const home = getHandSlotHomeAnchor(idx, shape);
    bounceToX = home.x;
    bounceToY = home.y;
  }

  // ✅ GAME OVER：先顯示視窗+分數，Firestore/排行榜在背景跑（避免卡死）
  function onGameOver() {
    // ✅ 本局最高 combo 顯示（新增）
    goCombo.textContent = `x${maxComboThisRun}`;

    // ✅ 更新本機「歷史最高 combo」（新增）
    if (maxComboThisRun > bestComboLocal) {
      bestComboLocal = maxComboThisRun;
      localStorage.setItem(LS_BEST_COMBO_KEY, String(bestComboLocal));
    }

    // UI 先出來（避免 await 卡住）
    switchTab("board");
    showOverlay();

    gameOverPanel.style.display = "block";
    goScore.textContent = `${score}分`;

    boardStatus.textContent = "正在結算/上傳分數中...";

    const name = getPlayerName();
    if (!name) {
      boardStatus.textContent = "未登入名字，無法上傳分數。";
      return;
    }

    // 背景處理：上傳 + 刷新排行榜（都有 timeout 保護）
    (async () => {
      try {
        await withTimeout(remoteUpsertBest(name, score, bestComboLocal, maxComboThisRun), 3500, "Firestore write timeout");
        boardStatus.textContent = "分數已上傳，排行榜更新中...";
        await refreshBoardUI();
      } catch (e) {
        console.error("[LB] upsert/refresh FAILED:", e);
        boardStatus.textContent = "⚠️ 分數上傳或更新超時（網路/Firestore）。你仍可查看排行榜。";
        try { await refreshBoardUI(); } catch (_) {}
      }
    })();
  }

  function handlePointerDown(e) {
    if (gameOver) return;
    canvas.setPointerCapture?.(e.pointerId);

    const pos = getCanvasPosFromClient(e.clientX, e.clientY);
    pointerX = pos.x; pointerY = pos.y;

    const idx = pickHandIndex(pos);
    if (idx !== null) {
      draggingIdx = idx;

      dragStartPX = pointerX;
      dragStartPY = pointerY;

      const home = getHandSlotHomeAnchor(draggingIdx, hand[draggingIdx]);
      dragStartAX = home.x;
      dragStartAY = home.y;

      dragNowAX = dragStartAX;
      dragNowAY = dragStartAY;
    }
  }

  function handlePointerMove(e) {
    const events = (e.getCoalescedEvents && e.getCoalescedEvents()) || null;
    const last = events && events.length ? events[events.length - 1] : e;

    const pos = getCanvasPosFromClient(last.clientX, last.clientY);
    pointerX = pos.x; pointerY = pos.y;

    if (draggingIdx !== null) {
      const dx = (pointerX - dragStartPX) * DRAG_GAIN;
      const dy = (pointerY - dragStartPY) * DRAG_GAIN;
      dragNowAX = dragStartAX + dx;
      dragNowAY = dragStartAY + dy;
    }
  }

  function handlePointerUpOrCancel() {
    if (draggingIdx === null) return;

    const shape = hand[draggingIdx];
    if (shape) {
      const anchorX = dragNowAX;
      const anchorY = dragNowAY;

      const best = findBestMagnet(shape, anchorX, anchorY);

      let r, c;
      if (best.can) { r = best.r; c = best.c; }
      else {
        r = Math.floor((anchorY - layout.gridY) / CELL_SIZE);
        c = Math.floor((anchorX - layout.gridX) / CELL_SIZE);
      }

      r = Math.max(0, Math.min(GRID_SIZE - 1, r));
      c = Math.max(0, Math.min(GRID_SIZE - 1, c));

      if (canPlace(shape, r, c)) {
        for (const coord of shape) grid[r + coord[0]][c + coord[1]] = 1;
        hand[draggingIdx] = null;
      // ✅ 成功放置反饋（新增）
        const placedCells = shape.map(([dr, dc]) => ({ r: r + dr, c: c + dc }));
        spawnPlaceParticles(placedCells);



        // combo：放置成功但沒消 -> 清 combo；放置失敗不清
        const cleared = checkAndClear();
        if (!cleared) { currentComboCount = 0; updateComboUI(); }

        if (hand.every(h => h === null)) refreshHand();

        let dead = true;
        for (const s of hand) {
          if (!s) continue;
          for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
              if (canPlace(s, i, j)) { dead = false; break; }
            }
            if (!dead) break;
          }
          if (!dead) break;
        }
        if (dead) { gameOver = true; onGameOver(); }
      } else {
        failFeedback();
        startBounceBack(draggingIdx, shape, anchorX, anchorY);
      }
    }

    draggingIdx = null;
  }

  canvas.addEventListener('pointerdown', handlePointerDown);
  window.addEventListener('pointermove', handlePointerMove);
  window.addEventListener('pointerup', handlePointerUpOrCancel);
  window.addEventListener('pointercancel', handlePointerUpOrCancel);
  window.addEventListener('pointerrawupdate', handlePointerMove);

  function drawHand() {
    const { slots } = layout.hand;

    if (layout.mode === "mobile") {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(layout.hand.x, layout.hand.y, layout.hand.w, layout.hand.h);
      ctx.restore();
    }

    for (let i = 0; i < 3; i++) {
      const shape = hand[i];
      const slot = slots[i];

      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 2;
      pathRoundedRect(slot.x + 6, slot.y + 6, slot.w - 12, slot.h - 12, 14);
      ctx.stroke();
      ctx.restore();

      if (!shape || i === draggingIdx) continue;

      const bb = shapeBoundingBox(shape);
      const block = layout.handBlock;
      const gap = layout.handGap;

      const shapeW = bb.w * (block + gap) - gap;
      const shapeH = bb.h * (block + gap) - gap;

      const startX = slot.x + (slot.w - shapeW) / 2;
      const startY = slot.y + (slot.h - shapeH) / 2;

      for (const coord of shape) {
        const x = startX + (coord[1] - bb.minC) * (block + gap);
        const y = startY + (coord[0] - bb.minR) * (block + gap);
        drawBlock(x, y, block, 6, currentTheme, 1);
      }
    }
  }

  function updateAndDrawBounce() {
    if (bounceLife <= 0 || !bounceShape || !bounceTheme) return;

    const t = 1 - bounceLife;
    const c1 = 1.70158;
    const c3 = c1 + 1;
    const easeOutBack = (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
    const k = easeOutBack(Math.min(1, Math.max(0, t)));

    const ax = bounceFromX + (bounceToX - bounceFromX) * k;
    const ay = bounceFromY + (bounceToY - bounceFromY) * k;

    const scale = 0.96 + 0.06 * (1 - Math.abs(0.5 - t) * 2);

    ctx.save();
    ctx.globalAlpha = 0.9 * bounceLife;

    for (const coord of bounceShape) {
      const x = ax + coord[1] * CELL_SIZE;
      const y = (ay - DRAG_LIFT * 0.45) + coord[0] * CELL_SIZE;
      const sx = x + (CELL_SIZE - 4) * (1 - scale) * 0.5;
      const sy = y + (CELL_SIZE - 4) * (1 - scale) * 0.5;
      drawBlock(sx, sy, (CELL_SIZE - 4) * scale, 8, bounceTheme, ctx.globalAlpha);
    }

    ctx.restore();

    bounceLife -= 0.06;
    if (bounceLife <= 0) { bounceLife = 0; bounceShape = null; }
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();

    if (shakeIntensity > 0) {
      ctx.translate((Math.random() - 0.5) * shakeIntensity, (Math.random() - 0.5) * shakeIntensity);
      shakeIntensity *= 0.8;
      if (shakeIntensity < 0.3) shakeIntensity = 0;
    }

    // 背景格
    ctx.fillStyle = '#333';
    for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) {
      const x = layout.gridX + c * CELL_SIZE + 2;
      const y = layout.gridY + r * CELL_SIZE + 2;
      ctx.fillRect(x, y, CELL_SIZE - 4, CELL_SIZE - 4);
    }

    // ✅ 外圈旋轉光暈
    drawRotatingHalo();

    if (currentTheme) {
      // 已放方塊（含 clearing 動畫）
      for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) {
        const cell = grid[r][c];
        if (cell === 1 || cell === 2) {
          const x = layout.gridX + c * CELL_SIZE + 2;
          const y = layout.gridY + r * CELL_SIZE + 2;

          if (cell === 1) {
            drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, 1);
          } else {
            const key = `${r},${c}`;
            const cc = clearingMap.get(key);
            const life = cc ? Math.max(0, cc.life) : 0.5;

            drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, 0.25 + 0.75 * life);

            ctx.save();
            ctx.globalAlpha = 0.35 * life;
            ctx.fillStyle = "rgba(255,255,255,1)";
            pathRoundedRect(x, y, CELL_SIZE - 4, CELL_SIZE - 4, 8);
            ctx.fill();
            ctx.restore();
          }
        }
      }

      updateAndDrawLineFlashes();

      // 拖曳 preview + 本體
      if (draggingIdx !== null && hand[draggingIdx]) {
        const shape = hand[draggingIdx];
        const anchorX = dragNowAX;
        const anchorY = dragNowAY;

        const best = findBestMagnet(shape, anchorX, anchorY);

        let previewR, previewC;
        if (best.can) { previewR = best.r; previewC = best.c; }
        else {
          previewR = Math.floor((anchorY - layout.gridY) / CELL_SIZE);
          previewC = Math.floor((anchorX - layout.gridX) / CELL_SIZE);
        }

        if (canPlace(shape, previewR, previewC)) {
          for (const coord of shape) {
            const x = layout.gridX + (previewC + coord[1]) * CELL_SIZE + 2;
            const y = layout.gridY + (previewR + coord[0]) * CELL_SIZE + 2;
            drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, PREVIEW_ALPHA_OK);
          }
        } else {
          ctx.save();
          ctx.globalAlpha = PREVIEW_ALPHA_BAD;
          ctx.fillStyle = "rgba(255,80,80,1)";
          ctx.fillRect(layout.gridX, layout.gridY, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
          ctx.restore();
        }

        const drawX = anchorX;
        const drawY = anchorY - DRAG_LIFT;
        for (const coord of shape) {
          const x = drawX + coord[1] * CELL_SIZE;
          const y = drawY + coord[0] * CELL_SIZE;
          drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, 1);
        }
      }

      drawHand();

      // ✅ 成功放置特效
      updateAndDrawPlaceRings();
      updateAndDrawPlaceParticles();

      // 既有：消除粒子、回彈、浮字
      updateAndDrawParticles();
      updateAndDrawBounce();
      updateAndDrawFloatingTexts();
    }

    // 失敗紅色 overlay
    if (failOverlayLife > 0) {
      ctx.save();
      ctx.globalAlpha = 0.30 * failOverlayLife;
      ctx.fillStyle = "rgba(255, 60, 60, 1)";
      ctx.fillRect(layout.gridX, layout.gridY, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
      ctx.restore();
      failOverlayLife -= 0.06;
      if (failOverlayLife < 0) failOverlayLife = 0;
    }

    ctx.restore();

    // ✅ clearing 動畫更新（真正清格）
    updateClearingCells();

    // ✅ 更新旋轉角度（順時針）
    haloAngle += haloSpeed;
    if (haloAngle > Math.PI * 2) haloAngle -= Math.PI * 2;

    // ✅ 每幀排程下一幀（一定要在 function 內）
    requestAnimationFrame(animate);
  }

  // ✅ 注意：這行不要放在 animate() 外面（你原本那行要刪掉）
  // requestAnimationFrame(animate);

  window.addEventListener('resize', () => applyLayout(computeLayout()));


  // ===== Boot =====
  (function boot() {
    const n = getPlayerName();
    if (n) nameInput.value = n;
    syncPlayerMini();

    applyLayout(computeLayout());
    resetGame();

    showOverlay();
    switchTab("login");
    animate();
  })();
</script>

</body>
</html>
