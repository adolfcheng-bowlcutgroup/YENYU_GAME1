<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>9x9 拼圖消消樂</title>
  <style>
    * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
    body {
      background-color: #1a1a1a;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;   /* fallback */
      height: 100dvh;  /* mobile stable viewport */
      justify-content: center;
      overflow: hidden;
    }
    .header {
      width: 100%;
      max-width: 600px;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      position: relative;
      margin-bottom: 10px;
      padding: 0 10px;
    }
    #highScoreContainer {
      position: absolute; left: 10px; bottom: 5px;
      background: rgba(255, 255, 255, 0.1);
      padding: 5px 10px; border-radius: 5px; border-left: 4px solid #FFD700;
    }
    #scoreDisplay {
      font-size: clamp(40px, 10vw, 70px);
      font-weight: bold;
      font-family: 'Arial Black', sans-serif;
    }
    #gameWrapper {
      position: relative;
      width: 95vw;
      max-width: 800px;
      display: flex;
      justify-content: center;
    }
    canvas {
      background-color: #222;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      width: 100%;
      height: auto;
      display: block;
      touch-action: none; /* 關鍵：手機避免捲動/縮放手勢干擾 */
    }
    #restartBtn {
      display: none;
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      padding: 15px 40px; font-size: 20px; font-weight: bold;
      color: white; border: none; border-radius: 30px;
      cursor: pointer; z-index: 100;
    }
  </style>
</head>
<body>

  <div class="header">
    <div id="highScoreContainer">
      <div style="font-size:10px;color:#aaa;">BEST</div>
      <div id="highScore">0</div>
    </div>
    <div id="scoreDisplay">0</div>
  </div>

  <div id="gameWrapper">
    <canvas id="gameCanvas"></canvas>
    <button id="restartBtn" onclick="resetGame()">PLAY AGAIN</button>
  </div>

<script>
/** =========================
 *  遊戲核心設定
 *  ========================= */
const GRID_SIZE = 9;
const CELL_SIZE = 55;

// 桌機右側手牌寬
const SIDEBAR_W = 250;

// 手機底部手牌高度（可依視覺微調）
const BOTTOMBAR_H = 220;

// 磁吸設定
const MAGNET_DISTANCE = 0.45; // 以 CELL_SIZE 的比例，越大越容易吸附 (0~1)
const MAGNET_OK_ALPHA = 0.30;

// 失敗回饋
const FAIL_SHAKE = 14;
const FAIL_VIBRATION_PATTERN = [25, 30, 25];

// 判斷「手機布局」門檻（你可調整）
function isMobileLayout() {
  return window.matchMedia("(max-width: 600px)").matches;
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const restartBtn = document.getElementById('restartBtn');

const THEMES = [
  { main: '#4A90E2', dark: '#21508A', light: '#A4C8F5' },
  { main: '#50E3C2', dark: '#2A8F79', light: '#B2F2E5' },
  { main: '#F5A623', dark: '#A36B0D', light: '#FCD9A1' }
];

const SHAPE_DEFS = [
  { shape: [[0,0], [0,1]], weight: 10 },
  { shape: [[0,0], [1,0]], weight: 10 },
  { shape: [[0,0], [0,1], [1,0], [1,1]], weight: 10 },
  { shape: [[0,0], [0,1], [0,2]], weight: 10 },
  { shape: [[0,0], [1,0], [2,0]], weight: 10 },
  { shape: [[0,0], [1,0], [1,1]], weight: 10 },
  { shape: [[0,0]], weight: 10 },
  { shape: [[0,0], [0,1], [0,2], [0,3]], weight: 10 },
  { shape: [[0,0], [1,0], [2,0], [3,0]], weight: 10 },
  { shape: [[0,0], [1,0], [1,1], [2,1]], weight: 10 },
  { shape: [[0,1], [0,2], [1,0], [1,1]], weight: 10 },
  { shape: [[0,1], [1,0], [1,1], [1,2]], weight: 10 },
  { shape: [[0,0], [1,0], [2,0], [2,1]], weight: 10 },
  { shape: [[0,0], [0,1], [0,2], [1,0], [2,0]], weight: 3 },
  { shape: [[0,1], [1,0], [1,1], [1,2], [2,1]], weight: 3 },
  { shape: [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2], [2,0], [2,1], [2,2]], weight: 3 }
];

/** =========================
 *  狀態
 *  ========================= */
let currentTheme;
let grid, hand, score, highScore;
let draggingIdx = null;
let pointerX = 0, pointerY = 0;
let gameOver = false;

let floatingTexts = [];
let shakeIntensity = 0;
let currentComboCount = 0;

// layout
let layout = null; // { mode, rawW, rawH, gridX, gridY, hand: {x,y,w,h, slots:[...]}, handBlock, handGap, ... }

/** =========================
 *  Layout 計算與 Canvas 尺寸
 *  ========================= */
function computeLayout() {
  const mobile = isMobileLayout();
  if (mobile) {
    const rawW = GRID_SIZE * CELL_SIZE;
    const rawH = GRID_SIZE * CELL_SIZE + BOTTOMBAR_H;

    // 底部手牌區
    const handX = 0;
    const handY = GRID_SIZE * CELL_SIZE;
    const handW = rawW;
    const handH = BOTTOMBAR_H;

    // 三個 slot（可按需要微調 padding）
    const padX = 20;
    const padY = 25;
    const slotW = (handW - padX * 2) / 3;
    const slotH = handH - padY * 2;

    const slots = [0,1,2].map(i => ({
      x: handX + padX + i * slotW,
      y: handY + padY,
      w: slotW,
      h: slotH
    }));

    return {
      mode: "mobile",
      rawW, rawH,
      gridX: 0, gridY: 0,
      hand: { x: handX, y: handY, w: handW, h: handH, slots },
      // 手牌顯示比例：手機略放大，好點選
      handBlock: 24,
      handCellGap: 4
    };
  } else {
    const rawW = GRID_SIZE * CELL_SIZE + SIDEBAR_W;
    const rawH = GRID_SIZE * CELL_SIZE;

    // 右側手牌區
    const handX = GRID_SIZE * CELL_SIZE;
    const handY = 0;
    const handW = SIDEBAR_W;
    const handH = rawH;

    // 三個 slot，沿用你原本大概的排法
    const slots = [0,1,2].map(i => ({
      x: handX + 20,
      y: 40 + i * 150,
      w: handW - 40,
      h: 120
    }));

    return {
      mode: "desktop",
      rawW, rawH,
      gridX: 0, gridY: 0,
      hand: { x: handX, y: handY, w: handW, h: handH, slots },
      handBlock: 20,
      handCellGap: 2
    };
  }
}

function applyLayout(newLayout) {
  layout = newLayout;
  canvas.width = layout.rawW;
  canvas.height = layout.rawH;
}

/** =========================
 *  畫圖工具
 *  ========================= */
function pathRoundedRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function drawBlock(x, y, size, r, theme, alpha = 1.0) {
  ctx.save();
  ctx.globalAlpha = alpha;
  pathRoundedRect(x, y, size, size, r);
  const g = ctx.createLinearGradient(x, y, x + size, y + size);
  g.addColorStop(0, theme.light);
  g.addColorStop(1, theme.dark);
  ctx.fillStyle = g;
  ctx.fill();
  ctx.fillStyle = "rgba(255,255,255,0.2)";
  ctx.beginPath();
  ctx.arc(x + size*0.3, y + size*0.3, size*0.15, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

/** =========================
 *  遊戲流程
 *  ========================= */
function resetGame() {
  // layout
  applyLayout(computeLayout());

  currentTheme = THEMES[Math.floor(Math.random() * THEMES.length)];
  restartBtn.style.backgroundColor = currentTheme.main;

  grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
  score = 0;
  highScore = Number(localStorage.getItem('blockHighScore') || 0);

  gameOver = false;
  floatingTexts = [];
  currentComboCount = 0;
  shakeIntensity = 0;

  document.getElementById('scoreDisplay').innerText = "0";
  document.getElementById('highScore').innerText = String(highScore);
  restartBtn.style.display = "none";

  refreshHand();
}

function refreshHand() {
  hand = [];
  for (let i = 0; i < 3; i++) {
    const totalW = SHAPE_DEFS.reduce((s, x) => s + x.weight, 0);
    let rand = Math.random() * totalW;
    let chosen = SHAPE_DEFS[0].shape;
    for (const def of SHAPE_DEFS) {
      if (rand < def.weight) { chosen = def.shape; break; }
      rand -= def.weight;
    }
    hand.push(chosen);
  }
}

function canPlace(shape, r, c) {
  if (!shape || r < 0 || c < 0) return false;
  for (let i = 0; i < shape.length; i++) {
    const nr = r + shape[i][0];
    const nc = c + shape[i][1];
    if (nr >= GRID_SIZE || nc >= GRID_SIZE || grid[nr][nc] === 1) return false;
  }
  return true;
}

function checkAndClear() {
  const rs = [], cs = [];

  for (let r = 0; r < GRID_SIZE; r++) {
    if (grid[r].every(v => v === 1)) rs.push(r);
  }
  for (let c = 0; c < GRID_SIZE; c++) {
    let full = true;
    for (let r = 0; r < GRID_SIZE; r++) if (grid[r][c] === 0) full = false;
    if (full) cs.push(c);
  }

  if (rs.length + cs.length > 0) {
    currentComboCount++;
    const lines = rs.length + cs.length;
    const gain = (lines * GRID_SIZE) + (lines - 1) * 5 + (currentComboCount * 5);
    score += gain;

    document.getElementById('scoreDisplay').innerText = String(score);

    if (score > highScore) {
      highScore = score;
      localStorage.setItem('blockHighScore', String(score));
      document.getElementById('highScore').innerText = String(score);
    }

    shakeIntensity = Math.max(shakeIntensity, lines * 8);

    const praise = ["", "Good！", "Nice Play！", "Great！", "Perfect！", "GOD LIKE！"][Math.min(currentComboCount, 5)];
    floatingTexts.push({
      txt: praise,
      x: layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
      y: layout.gridY + (GRID_SIZE * CELL_SIZE) / 2 - 30,
      life: 1,
      size: 25 + currentComboCount * 5
    });

    rs.forEach(r => { for (let c = 0; c < GRID_SIZE; c++) grid[r][c] = 0; });
    cs.forEach(c => { for (let r = 0; r < GRID_SIZE; r++) grid[r][c] = 0; });

  } else {
    currentComboCount = 0;
  }
}

/** =========================
 *  座標換算（CSS縮放 -> Raw座標）
 *  ========================= */
function getCanvasPosFromClient(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (canvas.width / (rect.width || 1));
  const y = (clientY - rect.top) * (canvas.height / (rect.height || 1));
  return { x, y };
}

/** =========================
 *  手牌命中測試
 *  ========================= */
function pickHandIndex(pos) {
  const { slots } = layout.hand;
  for (let i = 0; i < slots.length; i++) {
    const s = slots[i];
    if (pos.x >= s.x && pos.x <= s.x + s.w && pos.y >= s.y && pos.y <= s.y + s.h) {
      if (hand[i]) return i;
    }
  }
  return null;
}

/** =========================
 *  磁吸/吸附：計算「建議落點格」
 *  - 回傳 { r, c, snappedX, snappedY, can, distNorm }
 *  ========================= */
function getMagnetTarget(shape, posX, posY) {
  // 以「指標位置」作為 anchor 方塊 (shape[0]) 的參考點
  // 我們希望 anchor 對齊某個格子的左上角
  const gx = (posX - layout.gridX) / CELL_SIZE;
  const gy = (posY - layout.gridY) / CELL_SIZE;

  // 最近格子 index（允許在邊界附近）
  const c = Math.round(gx);
  const r = Math.round(gy);

  // 以格子的左上角作吸附點
  const snappedX = layout.gridX + c * CELL_SIZE;
  const snappedY = layout.gridY + r * CELL_SIZE;

  // 距離（用 cell 作正規化）
  const dx = (posX - snappedX) / CELL_SIZE;
  const dy = (posY - snappedY) / CELL_SIZE;
  const distNorm = Math.hypot(dx, dy);

  const can = canPlace(shape, r, c);
  return { r, c, snappedX, snappedY, can, distNorm };
}

/** =========================
 *  失敗回饋（震動＋抖動＋浮字）
 *  ========================= */
function failFeedback() {
  shakeIntensity = Math.max(shakeIntensity, FAIL_SHAKE);
  floatingTexts.push({
    txt: "放不下！",
    x: layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
    y: layout.gridY + (GRID_SIZE * CELL_SIZE) / 2,
    life: 1,
    size: 28
  });

  if (navigator.vibrate) {
    try { navigator.vibrate(FAIL_VIBRATION_PATTERN); } catch (_) {}
  }
}

/** =========================
 *  輸入（Pointer Events）
 *  ========================= */
function handlePointerDown(e) {
  if (gameOver) return;

  canvas.setPointerCapture?.(e.pointerId);

  const pos = getCanvasPosFromClient(e.clientX, e.clientY);
  pointerX = pos.x; pointerY = pos.y;

  const idx = pickHandIndex(pos);
  if (idx !== null) draggingIdx = idx;
}

function handlePointerMove(e) {
  const pos = getCanvasPosFromClient(e.clientX, e.clientY);
  pointerX = pos.x; pointerY = pos.y;
}

function handlePointerUpOrCancel() {
  if (draggingIdx === null) return;

  const shape = hand[draggingIdx];
  if (shape) {
    // 以 pointer 當 anchor，套用磁吸落點
    const target = getMagnetTarget(shape, pointerX, pointerY);

    // 實際落點採用：若距離夠近且可放 -> 吸附落點；否則用 floor 的自由落點
    let r, c;
    if (target.distNorm <= MAGNET_DISTANCE && target.can) {
      r = target.r; c = target.c;
    } else {
      // 自由落點（不吸附）採 floor，更穩
      r = Math.floor((pointerY - layout.gridY) / CELL_SIZE);
      c = Math.floor((pointerX - layout.gridX) / CELL_SIZE);
    }

    if (canPlace(shape, r, c)) {
      for (const coord of shape) {
        grid[r + coord[0]][c + coord[1]] = 1;
      }
      hand[draggingIdx] = null;

      checkAndClear();

      if (hand.every(h => h === null)) refreshHand();

      // 判定死局
      let dead = true;
      for (const s of hand) {
        if (!s) continue;
        for (let i = 0; i < GRID_SIZE; i++) {
          for (let j = 0; j < GRID_SIZE; j++) {
            if (canPlace(s, i, j)) { dead = false; break; }
          }
          if (!dead) break;
        }
        if (!dead) break;
      }
      if (dead) gameOver = true;
    } else {
      // 放置失敗：震動回饋
      failFeedback();
    }
  }

  draggingIdx = null;
}

canvas.addEventListener('pointerdown', handlePointerDown);
window.addEventListener('pointermove', handlePointerMove);
window.addEventListener('pointerup', handlePointerUpOrCancel);
window.addEventListener('pointercancel', handlePointerUpOrCancel);

/** =========================
 *  繪製：手牌
 *  ========================= */
function drawHand() {
  const { slots } = layout.hand;

  // 手牌區背景（手機底部做分隔感更明顯）
  if (layout.mode === "mobile") {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(layout.hand.x, layout.hand.y, layout.hand.w, layout.hand.h);
    ctx.restore();
  }

  for (let i = 0; i < 3; i++) {
    const s = hand[i];
    const slot = slots[i];

    // slot 框（可視化點選範圍，手機更友善）
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 2;
    pathRoundedRect(slot.x + 6, slot.y + 6, slot.w - 12, slot.h - 12, 14);
    ctx.stroke();
    ctx.restore();

    if (!s || i === draggingIdx) continue;

    // 把 shape 畫在 slot 中央
    const bb = shapeBoundingBox(s);
    const block = layout.handBlock;
    const gap = layout.handCellGap;

    const shapeW = bb.w * (block + gap) - gap;
    const shapeH = bb.h * (block + gap) - gap;

    const startX = slot.x + (slot.w - shapeW) / 2;
    const startY = slot.y + (slot.h - shapeH) / 2;

    for (const coord of s) {
      const x = startX + (coord[1] - bb.minC) * (block + gap);
      const y = startY + (coord[0] - bb.minR) * (block + gap);
      drawBlock(x, y, block, 6, currentTheme, 1);
    }
  }
}

function shapeBoundingBox(shape) {
  let minR = Infinity, minC = Infinity, maxR = -Infinity, maxC = -Infinity;
  for (const [r,c] of shape) {
    minR = Math.min(minR, r); minC = Math.min(minC, c);
    maxR = Math.max(maxR, r); maxC = Math.max(maxC, c);
  }
  return { minR, minC, maxR, maxC, w: maxC - minC + 1, h: maxR - minR + 1 };
}

/** =========================
 *  繪製：主迴圈
 *  ========================= */
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();

  // 抖動（成功清線/失敗放置）
  if (shakeIntensity > 0) {
    ctx.translate((Math.random() - 0.5) * shakeIntensity, (Math.random() - 0.5) * shakeIntensity);
    shakeIntensity *= 0.8;
    if (shakeIntensity < 0.3) shakeIntensity = 0;
  }

  // 背景格（只畫棋盤區）
  ctx.fillStyle = '#333';
  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
      const x = layout.gridX + c * CELL_SIZE + 2;
      const y = layout.gridY + r * CELL_SIZE + 2;
      ctx.fillRect(x, y, CELL_SIZE - 4, CELL_SIZE - 4);
    }
  }

  // 固定方塊
  if (currentTheme) {
    for (let r = 0; r < GRID_SIZE; r++) {
      for (let c = 0; c < GRID_SIZE; c++) {
        if (grid[r][c]) {
          const x = layout.gridX + c * CELL_SIZE + 2;
          const y = layout.gridY + r * CELL_SIZE + 2;
          drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme);
        }
      }
    }

    // 拖曳預覽＆磁吸
    if (draggingIdx !== null && hand[draggingIdx]) {
      const shape = hand[draggingIdx];

      const target = getMagnetTarget(shape, pointerX, pointerY);

      const shouldMagnet = (target.distNorm <= MAGNET_DISTANCE && target.can);

      // 預覽落點（如果可放置）
      let previewR, previewC;
      if (shouldMagnet) {
        previewR = target.r; previewC = target.c;
      } else {
        previewR = Math.floor((pointerY - layout.gridY) / CELL_SIZE);
        previewC = Math.floor((pointerX - layout.gridX) / CELL_SIZE);
      }

      if (canPlace(shape, previewR, previewC)) {
        for (const coord of shape) {
          const x = layout.gridX + (previewC + coord[1]) * CELL_SIZE + 2;
          const y = layout.gridY + (previewR + coord[0]) * CELL_SIZE + 2;
          drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, MAGNET_OK_ALPHA);
        }
      }

      // 拖曳中的方塊「顯示位置」：磁吸時吸到格子左上角；否則跟手指
      let drawX = pointerX;
      let drawY = pointerY;

      if (shouldMagnet) {
        // 讓 anchor（shape 的 [0,0]）貼到 snappedX/Y，再加上偏移讓顯示更自然
        // 你原本用 -25，這裡用 CELL_SIZE * 0.45 讓視覺接近中心
        drawX = target.snappedX + CELL_SIZE * 0.10;
        drawY = target.snappedY + CELL_SIZE * 0.10;
      } else {
        drawX = pointerX - CELL_SIZE * 0.45;
        drawY = pointerY - CELL_SIZE * 0.45;
      }

      for (const coord of shape) {
        const x = drawX + coord[1] * CELL_SIZE;
        const y = drawY + coord[0] * CELL_SIZE;
        drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, 1);
      }
    }

    // 手牌（底部 or 右側）
    drawHand();
  }

  // 浮字
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y -= 1;
    t.life -= 0.02;

    ctx.globalAlpha = Math.max(0, t.life);
    ctx.fillStyle = "#FFD700";
    ctx.textAlign = "center";
    ctx.font = "bold " + t.size + "px Arial";
    ctx.fillText(t.txt, t.x, t.y);

    if (t.life <= 0) floatingTexts.splice(i, 1);
  }
  ctx.globalAlpha = 1;

  // GAME OVER
  if (gameOver) {
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white";
    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
    restartBtn.style.display = "block";
  }

  ctx.restore();
  requestAnimationFrame(animate);
}

/** =========================
 *  resize：切換手機/桌機布局（不重置遊戲）
 *  ========================= */
function handleResize() {
  const prevMode = layout?.mode;
  const newLayout = computeLayout();
  if (!layout || prevMode !== newLayout.mode) {
    // 模式切換（手機<->桌機），只更新 canvas 尺寸與 layout，不動棋盤/手牌/分數
    applyLayout(newLayout);
  } else {
    // 同模式尺寸更新（大多 no-op）
    applyLayout(newLayout);
  }
}
window.addEventListener('resize', handleResize);

/** =========================
 *  啟動
 *  ========================= */
resetGame();
animate();
</script>

</body>
</html>
