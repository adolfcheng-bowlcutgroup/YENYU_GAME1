<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>9x9 拼圖消消樂</title>
  <style>
    * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
    body {
      background-color: #1a1a1a;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;   /* fallback */
      height: 100dvh;  /* iOS/modern mobile stable viewport */
      justify-content: center;
      overflow: hidden;
    }
    .header {
      width: 100%;
      max-width: 600px;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      position: relative;
      margin-bottom: 10px;
      padding: 0 10px;
    }
    #highScoreContainer {
      position: absolute; left: 10px; bottom: 5px;
      background: rgba(255, 255, 255, 0.1);
      padding: 5px 10px; border-radius: 5px; border-left: 4px solid #FFD700;
    }
    #scoreDisplay {
      font-size: clamp(40px, 10vw, 70px);
      font-weight: bold;
      font-family: 'Arial Black', sans-serif;
    }
    #gameWrapper {
      position: relative;
      width: 95vw;
      max-width: 800px;
      display: flex;
      justify-content: center;
    }
    canvas {
      background-color: #222;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      width: 100%;
      height: auto;
      display: block;

      /* 手機關鍵：讓瀏覽器不要把拖曳當作捲動/縮放手勢 */
      touch-action: none;
    }
    #restartBtn {
      display: none;
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      padding: 15px 40px; font-size: 20px; font-weight: bold;
      color: white; border: none; border-radius: 30px;
      cursor: pointer; z-index: 100;
    }
  </style>
</head>
<body>

  <div class="header">
    <div id="highScoreContainer">
      <div style="font-size:10px;color:#aaa;">BEST</div>
      <div id="highScore">0</div>
    </div>
    <div id="scoreDisplay">0</div>
  </div>

  <div id="gameWrapper">
    <canvas id="gameCanvas"></canvas>
    <button id="restartBtn" onclick="resetGame()">PLAY AGAIN</button>
  </div>

<script>
/** 遊戲核心設定 **/
const GRID_SIZE = 9;
const CELL_SIZE = 55;
const SIDEBAR = 250;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const restartBtn = document.getElementById('restartBtn');

const RAW_WIDTH = (GRID_SIZE * CELL_SIZE) + SIDEBAR;
const RAW_HEIGHT = GRID_SIZE * CELL_SIZE;
canvas.width = RAW_WIDTH;
canvas.height = RAW_HEIGHT;

const THEMES = [
  { main: '#4A90E2', dark: '#21508A', light: '#A4C8F5' },
  { main: '#50E3C2', dark: '#2A8F79', light: '#B2F2E5' },
  { main: '#F5A623', dark: '#A36B0D', light: '#FCD9A1' }
];

const SHAPE_DEFS = [
  { shape: [[0,0], [0,1]], weight: 10 },
  { shape: [[0,0], [1,0]], weight: 10 },
  { shape: [[0,0], [0,1], [1,0], [1,1]], weight: 10 },
  { shape: [[0,0], [0,1], [0,2]], weight: 10 },
  { shape: [[0,0], [1,0], [2,0]], weight: 10 },
  { shape: [[0,0], [1,0], [1,1]], weight: 10 },
  { shape: [[0,0]], weight: 10 },
  { shape: [[0,0], [0,1], [0,2], [0,3]], weight: 10 },
  { shape: [[0,0], [1,0], [2,0], [3,0]], weight: 10 },
  { shape: [[0,0], [1,0], [1,1], [2,1]], weight: 10 },
  { shape: [[0,1], [0,2], [1,0], [1,1]], weight: 10 },
  { shape: [[0,1], [1,0], [1,1], [1,2]], weight: 10 },
  { shape: [[0,0], [1,0], [2,0], [2,1]], weight: 10 },
  { shape: [[0,0], [0,1], [0,2], [1,0], [2,0]], weight: 3 },
  { shape: [[0,1], [1,0], [1,1], [1,2], [2,1]], weight: 3 },
  { shape: [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2], [2,0], [2,1], [2,2]], weight: 3 }
];

let currentTheme, grid, hand, score, highScore;
let draggingIdx = null;
let mouseX = 0, mouseY = 0;
let gameOver = false;

let floatingTexts = [];
let shakeIntensity = 0;
let currentComboCount = 0;

/** 繪圖工具 **/
function pathRoundedRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function drawBlock(x, y, size, r, theme, alpha = 1.0) {
  ctx.save();
  ctx.globalAlpha = alpha;
  pathRoundedRect(x, y, size, size, r);
  const g = ctx.createLinearGradient(x, y, x + size, y + size);
  g.addColorStop(0, theme.light);
  g.addColorStop(1, theme.dark);
  ctx.fillStyle = g;
  ctx.fill();
  ctx.fillStyle = "rgba(255,255,255,0.2)";
  ctx.beginPath();
  ctx.arc(x + size*0.3, y + size*0.3, size*0.15, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

/** 遊戲流程 **/
function resetGame() {
  currentTheme = THEMES[Math.floor(Math.random() * THEMES.length)];
  restartBtn.style.backgroundColor = currentTheme.main;

  grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
  score = 0;
  highScore = Number(localStorage.getItem('blockHighScore') || 0);

  gameOver = false;
  floatingTexts = [];
  currentComboCount = 0;

  document.getElementById('scoreDisplay').innerText = "0";
  document.getElementById('highScore').innerText = String(highScore);
  restartBtn.style.display = "none";

  refreshHand();
}

function refreshHand() {
  hand = [];
  for (let i = 0; i < 3; i++) {
    const totalW = SHAPE_DEFS.reduce((s, x) => s + x.weight, 0);
    let rand = Math.random() * totalW;
    let chosen = SHAPE_DEFS[0].shape;
    for (const def of SHAPE_DEFS) {
      if (rand < def.weight) { chosen = def.shape; break; }
      rand -= def.weight;
    }
    hand.push(chosen);
  }
}

function canPlace(shape, r, c) {
  if (!shape || r < 0 || c < 0) return false;
  for (let i = 0; i < shape.length; i++) {
    const nr = r + shape[i][0];
    const nc = c + shape[i][1];
    if (nr >= GRID_SIZE || nc >= GRID_SIZE || grid[nr][nc] === 1) return false;
  }
  return true;
}

function checkAndClear() {
  const rs = [], cs = [];

  for (let r = 0; r < GRID_SIZE; r++) {
    if (grid[r].every(v => v === 1)) rs.push(r);
  }
  for (let c = 0; c < GRID_SIZE; c++) {
    let full = true;
    for (let r = 0; r < GRID_SIZE; r++) if (grid[r][c] === 0) full = false;
    if (full) cs.push(c);
  }

  if (rs.length + cs.length > 0) {
    currentComboCount++;
    const lines = rs.length + cs.length;
    const gain = (lines * GRID_SIZE) + (lines - 1) * 5 + (currentComboCount * 5);
    score += gain;

    document.getElementById('scoreDisplay').innerText = String(score);

    if (score > highScore) {
      highScore = score;
      localStorage.setItem('blockHighScore', String(score));
      document.getElementById('highScore').innerText = String(score);
    }

    shakeIntensity = lines * 8;
    const praise = ["", "Good！", "Nice Play！", "Great！", "Perfect！", "GOD LIKE！"][Math.min(currentComboCount, 5)];
    floatingTexts.push({
      txt: praise,
      x: (GRID_SIZE * CELL_SIZE) / 2,
      y: (GRID_SIZE * CELL_SIZE) / 2 - 30,
      life: 1,
      size: 25 + currentComboCount * 5
    });

    rs.forEach(r => { for (let c = 0; c < GRID_SIZE; c++) grid[r][c] = 0; });
    cs.forEach(c => { for (let r = 0; r < GRID_SIZE; r++) grid[r][c] = 0; });

  } else {
    currentComboCount = 0;
  }
}

/** 位置換算（CSS縮放 -> Raw座標） **/
function getCanvasPosFromClient(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (RAW_WIDTH / (rect.width || 1));
  const y = (clientY - rect.top) * (RAW_HEIGHT / (rect.height || 1));
  return { x, y };
}

/** 輸入（Pointer Events 一套吃滑鼠/觸控） **/
function handlePointerDown(e) {
  if (gameOver) return;
  canvas.setPointerCapture?.(e.pointerId);

  const pos = getCanvasPosFromClient(e.clientX, e.clientY);
  mouseX = pos.x; mouseY = pos.y;

  if (pos.x > GRID_SIZE * CELL_SIZE) {
    const idx = Math.floor((pos.y - 40) / 150);
    if (idx >= 0 && idx < 3 && hand[idx]) draggingIdx = idx;
  }
}

function handlePointerMove(e) {
  const pos = getCanvasPosFromClient(e.clientX, e.clientY);
  mouseX = pos.x; mouseY = pos.y;
}

function handlePointerUpOrCancel() {
  if (draggingIdx !== null) {
    // 手機穩定：用 floor 不用 round，落點比較不抖
    const r = Math.floor(mouseY / CELL_SIZE);
    const c = Math.floor(mouseX / CELL_SIZE);

    if (canPlace(hand[draggingIdx], r, c)) {
      for (const coord of hand[draggingIdx]) {
        grid[r + coord[0]][c + coord[1]] = 1;
      }
      hand[draggingIdx] = null;

      checkAndClear();

      if (hand.every(h => h === null)) refreshHand();

      // 判定是否死局
      let dead = true;
      for (const s of hand) {
        if (!s) continue;
        for (let i = 0; i < GRID_SIZE; i++) {
          for (let j = 0; j < GRID_SIZE; j++) {
            if (canPlace(s, i, j)) { dead = false; break; }
          }
          if (!dead) break;
        }
        if (!dead) break;
      }
      if (dead) gameOver = true;
    }
    draggingIdx = null;
  }
}

canvas.addEventListener('pointerdown', handlePointerDown);
window.addEventListener('pointermove', handlePointerMove);
window.addEventListener('pointerup', handlePointerUpOrCancel);
window.addEventListener('pointercancel', handlePointerUpOrCancel);

/** 繪製 **/
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  if (shakeIntensity > 0) {
    ctx.translate((Math.random() - 0.5) * shakeIntensity, (Math.random() - 0.5) * shakeIntensity);
    shakeIntensity *= 0.8;
  }

  // 背景格
  ctx.fillStyle = '#333';
  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
      ctx.fillRect(c * CELL_SIZE + 2, r * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
    }
  }

  if (currentTheme) {
    // 固定方塊
    for (let r = 0; r < GRID_SIZE; r++) {
      for (let c = 0; c < GRID_SIZE; c++) {
        if (grid[r][c]) drawBlock(c * CELL_SIZE + 2, r * CELL_SIZE + 2, CELL_SIZE - 4, 8, currentTheme);
      }
    }

    // 預覽（半透明）
    if (draggingIdx !== null && hand[draggingIdx]) {
      const r = Math.floor(mouseY / CELL_SIZE);
      const c = Math.floor(mouseX / CELL_SIZE);
      if (canPlace(hand[draggingIdx], r, c)) {
        for (const coord of hand[draggingIdx]) {
          drawBlock((c + coord[1]) * CELL_SIZE + 2, (r + coord[0]) * CELL_SIZE + 2, CELL_SIZE - 4, 8, currentTheme, 0.3);
        }
      }
    }

    // 右側手牌
    hand.forEach((s, i) => {
      if (!s || i === draggingIdx) return;
      const bx = GRID_SIZE * CELL_SIZE + 60;
      const by = 60 + i * 150;
      for (const coord of s) drawBlock(bx + coord[1] * 22, by + coord[0] * 22, 20, 4, currentTheme);
    });

    // 跟隨拖曳的方塊
    if (draggingIdx !== null && hand[draggingIdx]) {
      for (const coord of hand[draggingIdx]) {
        drawBlock(mouseX + coord[1] * CELL_SIZE - 25, mouseY + coord[0] * CELL_SIZE - 25, CELL_SIZE - 4, 8, currentTheme);
      }
    }
  }

  // 浮字
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y -= 1;
    t.life -= 0.02;

    ctx.globalAlpha = Math.max(0, t.life);
    ctx.fillStyle = "#FFD700";
    ctx.textAlign = "center";
    ctx.font = "bold " + t.size + "px Arial";
    ctx.fillText(t.txt, t.x, t.y);

    if (t.life <= 0) floatingTexts.splice(i, 1);
  }
  ctx.globalAlpha = 1;

  // Game over overlay
  if (gameOver) {
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white";
    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
    restartBtn.style.display = "block";
  }

  ctx.restore();
  requestAnimationFrame(animate);
}

// 保險：螢幕旋轉/縮放後，CSS尺寸會變，但你用 boundingRect 換算，所以不用改 canvas 實體尺寸。
// 這裡主要是避免某些瀏覽器在旋轉時 pointer 座標短暫跳動。
window.addEventListener('resize', () => {
  // no-op: keep for future layout adjustments
});

/** 啟動 **/
resetGame();
animate();
</script>

</body>
</html>
