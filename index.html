<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>9x9 拼圖消消樂</title>
  <style>
    * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
    body{
      background:#1a1a1a; color:#fff; margin:0;
      height:100vh; height:100dvh;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      font-family: Arial, sans-serif;
      overflow:hidden;
    }
    .header{
      width:100%; max-width:700px;
      display:flex; justify-content:center; align-items:flex-end;
      position:relative; margin-bottom:10px; padding:0 10px;
    }
    #highScoreContainer{
      position:absolute; left:10px; bottom:5px;
      background:rgba(255,255,255,0.1);
      padding:5px 10px; border-radius:5px; border-left:4px solid #FFD700;
    }
    #scoreDisplay{
      font-size:clamp(40px, 10vw, 70px);
      font-weight:900;
      font-family:'Arial Black', sans-serif;
    }
    #comboBadge{
      position:absolute; right:10px; bottom:5px;
      z-index: 50;              /* ✅ 重要：避免被分數蓋住 */
      color: white;
      background:rgba(255,255,255,0.10);
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.18);
      display:none;
      font-weight:900;
      letter-spacing:.5px;
      user-select:none; -webkit-user-select:none;
      pointer-events: none;
    }
    #comboBadge .label{ font-size:10px; color:#aaa; margin-right:6px; font-weight:700; }
    #comboBadge .value{ font-size:14px; }

    #gameWrapper{
      position:relative;
      width:95vw; max-width:820px;
      display:flex; justify-content:center;
    }
    canvas{
      background:#222;
      border-radius:12px;
      box-shadow:0 10px 40px rgba(0,0,0,0.5);
      width:100%; height:auto; display:block;
      touch-action:none;
    }
    #restartBtn{
      display:none;
      position:absolute; top:50%; left:50%;
      transform:translate(-50%, -50%);
      padding:15px 40px; font-size:20px; font-weight:900;
      color:#fff; border:none; border-radius:30px;
      cursor:pointer; z-index:100;
    }
  </style>
</head>
<body>

  <div class="header">
    <div id="highScoreContainer">
      <div style="font-size:10px;color:#aaa;">BEST</div>
      <div id="highScore">0</div>
    </div>

    <div id="scoreDisplay">0</div>

    <div id="comboBadge">
      <span class="label">COMBO</span>
      <span class="value" id="comboCount">x1</span>
    </div>
  </div>

  <div id="gameWrapper">
    <canvas id="gameCanvas"></canvas>
    <button id="restartBtn" onclick="resetGame()">PLAY AGAIN</button>
  </div>

<script>
/** =========================
 *  核心設定
 *  ========================= */
const GRID_SIZE = 9;
const CELL_SIZE = 55;

const SIDEBAR_W = 250;
const BOTTOMBAR_H = 220;

// 手指移動較短、方塊移動較遠
const DRAG_GAIN = 1.6;

// 磁吸：找附近最近且可放置
const MAGNET_SEARCH_RADIUS = 2;

// 預覽透明度
const PREVIEW_ALPHA_OK = 0.28;
const PREVIEW_ALPHA_BAD = 0.14;

// 拖曳抬起（減少手指遮擋）
const DRAG_LIFT = CELL_SIZE * 0.9;

// 放置失敗回饋
const FAIL_SHAKE = 14;
const FAIL_VIBRATION_PATTERN = [25, 30, 25];

// 回彈與紅提示
let failOverlayLife = 0;
let bounceLife = 0;
let bounceFromX = 0, bounceFromY = 0;
let bounceToX = 0, bounceToY = 0;
let bounceShape = null;
let bounceTheme = null;

// 消除特效
let particles = [];
let lineFlashes = [];

// Drag gain 狀態（anchor）
let dragStartPX = 0, dragStartPY = 0;
let dragStartAX = 0, dragStartAY = 0;
let dragNowAX = 0, dragNowAY = 0;

function isMobileLayout() {
  return window.matchMedia("(max-width: 600px)").matches;
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const restartBtn = document.getElementById('restartBtn');

const comboBadge = document.getElementById('comboBadge');
const comboCountEl = document.getElementById('comboCount');

const THEMES = [
  { main:'#4A90E2', dark:'#21508A', light:'#A4C8F5' },
  { main:'#50E3C2', dark:'#2A8F79', light:'#B2F2E5' },
  { main:'#F5A623', dark:'#A36B0D', light:'#FCD9A1' }
];

const SHAPE_DEFS = [
  { shape: [[0,0],[0,1]], weight: 10 },
  { shape: [[0,0],[1,0]], weight: 10 },
  { shape: [[0,0],[0,1],[1,0],[1,1]], weight: 10 },
  { shape: [[0,0],[0,1],[0,2]], weight: 10 },
  { shape: [[0,0],[1,0],[2,0]], weight: 10 },
  { shape: [[0,0],[1,0],[1,1]], weight: 10 },
  { shape: [[0,0]], weight: 10 },
  { shape: [[0,0],[0,1],[0,2],[0,3]], weight: 10 },
  { shape: [[0,0],[1,0],[2,0],[3,0]], weight: 10 },
  { shape: [[0,0],[1,0],[1,1],[2,1]], weight: 10 },
  { shape: [[0,1],[0,2],[1,0],[1,1]], weight: 10 },
  { shape: [[0,1],[1,0],[1,1],[1,2]], weight: 10 },
  { shape: [[0,0],[1,0],[2,0],[2,1]], weight: 10 },
  { shape: [[0,0],[0,1],[0,2],[1,0],[2,0]], weight: 3 },
  { shape: [[0,1],[1,0],[1,1],[1,2],[2,1]], weight: 3 },
  { shape: [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]], weight: 3 }
];

/** =========================
 *  狀態
 *  ========================= */
let currentTheme;
let grid, hand, score, highScore;

let draggingIdx = null;
let pointerX = 0, pointerY = 0;
let gameOver = false;

let shakeIntensity = 0;
let currentComboCount = 0;

// 浮字：支援多行/顏色/描邊
// item: { lines:[{txt,color,sizeMul}], x,y, life, vy, size, stroke, align }
let floatingTexts = [];

let layout = null;

/** =========================
 *  Combo UI + Tier
 *  ========================= */
function getComboTier(combo) {
  if (combo >= 6) return { name:"GODLIKE", color:"#FFEA00", glow:"rgba(255,234,0,0.75)", border:"rgba(255,234,0,0.55)" };
  if (combo >= 4) return { name:"PERFECT", color:"#FFD700", glow:"rgba(255,215,0,0.65)", border:"rgba(255,215,0,0.45)" };
  if (combo >= 3) return { name:"GREAT",   color:"#7CFCFF", glow:"rgba(124,252,255,0.55)", border:"rgba(124,252,255,0.40)" };
  if (combo >= 2) return { name:"NICE",    color:"#B7FF6A", glow:"rgba(183,255,106,0.45)", border:"rgba(183,255,106,0.35)" };
  return             { name:"GOOD",    color:"#FFFFFF", glow:"rgba(255,255,255,0.30)", border:"rgba(255,255,255,0.20)" };
}

const DEBUG_SHOW_COMBO_WHEN_ZERO = true; // ✅ 你確認 OK 後改 false

function updateComboUI() {
  if (currentComboCount > 0) {
    comboBadge.style.display = "inline-flex"; // ✅ 強制顯示
    comboBadge.style.alignItems = "center";
    comboCountEl.innerText = "x" + currentComboCount;

    const tier = getComboTier(currentComboCount);
    comboBadge.style.borderColor = tier.border;
    comboBadge.style.boxShadow = `0 0 18px ${tier.glow}`;
    comboBadge.style.opacity = "1";
  } else {
    if (DEBUG_SHOW_COMBO_WHEN_ZERO) {
      // ✅ 開發用：即使 0 也顯示，確認 UI 沒被吃掉
      comboBadge.style.display = "inline-flex";
      comboBadge.style.alignItems = "center";
      comboCountEl.innerText = "x0";
      comboBadge.style.borderColor = "rgba(255,255,255,0.18)";
      comboBadge.style.boxShadow = "none";
      comboBadge.style.opacity = "0.35";
    } else {
      comboBadge.style.display = "none";
    }
  }
}


/** =========================
 *  Layout
 *  ========================= */
function computeLayout() {
  const mobile = isMobileLayout();
  if (mobile) {
    const rawW = GRID_SIZE * CELL_SIZE;
    const rawH = GRID_SIZE * CELL_SIZE + BOTTOMBAR_H;

    const handX = 0;
    const handY = GRID_SIZE * CELL_SIZE;
    const handW = rawW;
    const handH = BOTTOMBAR_H;

    const padX = 20;
    const padY = 25;
    const slotW = (handW - padX * 2) / 3;
    const slotH = handH - padY * 2;

    const slots = [0,1,2].map(i => ({
      x: handX + padX + i * slotW,
      y: handY + padY,
      w: slotW,
      h: slotH
    }));

    return {
      mode: "mobile",
      rawW, rawH,
      gridX: 0, gridY: 0,
      hand: { x: handX, y: handY, w: handW, h: handH, slots },
      handBlock: 24,
      handGap: 4
    };
  } else {
    const rawW = GRID_SIZE * CELL_SIZE + SIDEBAR_W;
    const rawH = GRID_SIZE * CELL_SIZE;

    const handX = GRID_SIZE * CELL_SIZE;
    const handY = 0;
    const handW = SIDEBAR_W;
    const handH = rawH;

    const slots = [0,1,2].map(i => ({
      x: handX + 20,
      y: 40 + i * 150,
      w: handW - 40,
      h: 120
    }));

    return {
      mode: "desktop",
      rawW, rawH,
      gridX: 0, gridY: 0,
      hand: { x: handX, y: handY, w: handW, h: handH, slots },
      handBlock: 20,
      handGap: 2
    };
  }
}

function applyLayout(newLayout) {
  layout = newLayout;
  canvas.width = layout.rawW;
  canvas.height = layout.rawH;
}

/** =========================
 *  繪圖工具
 *  ========================= */
function pathRoundedRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function drawBlock(x, y, size, r, theme, alpha = 1.0) {
  ctx.save();
  ctx.globalAlpha = alpha;
  pathRoundedRect(x, y, size, size, r);
  const g = ctx.createLinearGradient(x, y, x + size, y + size);
  g.addColorStop(0, theme.light);
  g.addColorStop(1, theme.dark);
  ctx.fillStyle = g;
  ctx.fill();
  ctx.fillStyle = "rgba(255,255,255,0.2)";
  ctx.beginPath();
  ctx.arc(x + size*0.3, y + size*0.3, size*0.15, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawTextWithStroke(txt, x, y, size, color, stroke = "rgba(0,0,0,0.55)", align = "center") {
  ctx.save();
  ctx.font = `900 ${size}px Arial`;
  ctx.textAlign = align;
  ctx.textBaseline = "middle";
  ctx.lineWidth = Math.max(3, size * 0.12);
  ctx.strokeStyle = stroke;
  ctx.fillStyle = color;
  ctx.strokeText(txt, x, y);
  ctx.fillText(txt, x, y);
  ctx.restore();
}

/** =========================
 *  遊戲流程
 *  ========================= */
function resetGame() {
  applyLayout(computeLayout());

  currentTheme = THEMES[Math.floor(Math.random() * THEMES.length)];
  restartBtn.style.backgroundColor = currentTheme.main;

  grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
  score = 0;
  highScore = Number(localStorage.getItem('blockHighScore') || 0);

  gameOver = false;
  shakeIntensity = 0;
  currentComboCount = 0;
  floatingTexts = [];
  particles = [];
  lineFlashes = [];
  failOverlayLife = 0;
  bounceLife = 0;

  document.getElementById('scoreDisplay').innerText = "0";
  document.getElementById('highScore').innerText = String(highScore);
  restartBtn.style.display = "none";

  updateComboUI();
  refreshHand();
}

function refreshHand() {
  hand = [];
  for (let i = 0; i < 3; i++) {
    const totalW = SHAPE_DEFS.reduce((s, x) => s + x.weight, 0);
    let rand = Math.random() * totalW;
    let chosen = SHAPE_DEFS[0].shape;
    for (const def of SHAPE_DEFS) {
      if (rand < def.weight) { chosen = def.shape; break; }
      rand -= def.weight;
    }
    hand.push(chosen);
  }
}

function canPlace(shape, r, c) {
  if (!shape || r < 0 || c < 0) return false;
  for (let i = 0; i < shape.length; i++) {
    const nr = r + shape[i][0];
    const nc = c + shape[i][1];
    if (nr >= GRID_SIZE || nc >= GRID_SIZE || grid[nr][nc] === 1) return false;
  }
  return true;
}

/** =========================
 *  特效：粒子 / 閃光
 *  ========================= */
function spawnClearParticles(cells) {
  for (const {r, c} of cells) {
    const cx = layout.gridX + c * CELL_SIZE + CELL_SIZE / 2;
    const cy = layout.gridY + r * CELL_SIZE + CELL_SIZE / 2;

    const n = 10 + Math.floor(Math.random() * 6);
    for (let i = 0; i < n; i++) {
      const ang = Math.random() * Math.PI * 2;
      const spd = 2 + Math.random() * 6;
      particles.push({
        x: cx, y: cy,
        vx: Math.cos(ang) * spd,
        vy: Math.sin(ang) * spd - 1.5,
        life: 1,
        size: 2 + Math.random() * 3
      });
    }
  }
}

function updateAndDrawParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life -= 0.03;
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2;
    p.vx *= 0.98;
    p.vy *= 0.98;

    if (p.life <= 0) { particles.splice(i, 1); continue; }

    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = "rgba(255, 215, 0, 1)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.beginPath();
    ctx.arc(p.x - 1, p.y - 1, p.size * 0.55, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

function spawnLineFlash(rows, cols) {
  for (const r of rows) lineFlashes.push({ type:'row', idx:r, life:1 });
  for (const c of cols) lineFlashes.push({ type:'col', idx:c, life:1 });
}

function updateAndDrawLineFlashes() {
  for (let i = lineFlashes.length - 1; i >= 0; i--) {
    const f = lineFlashes[i];
    f.life -= 0.06;
    if (f.life <= 0) { lineFlashes.splice(i, 1); continue; }

    ctx.save();
    ctx.globalAlpha = Math.max(0, f.life);
    ctx.fillStyle = "rgba(255,255,255,0.65)";
    if (f.type === 'row') {
      const y = layout.gridY + f.idx * CELL_SIZE;
      ctx.fillRect(layout.gridX, y, GRID_SIZE * CELL_SIZE, CELL_SIZE);
    } else {
      const x = layout.gridX + f.idx * CELL_SIZE;
      ctx.fillRect(x, layout.gridY, CELL_SIZE, GRID_SIZE * CELL_SIZE);
    }
    ctx.restore();
  }
}

/** =========================
 *  浮字：breakdown + tier
 *  ========================= */
function pushFloatingBreakdown(x, y, tier, base, multi, comboBonus, gain) {
  const lines = [];
  lines.push({ txt: tier.name, color: tier.color, sizeMul: 1.25 });
  lines.push({ txt: `+${gain} TOTAL`, color: "#FFD700", sizeMul: 1.05 });
  lines.push({ txt: `+${base} Base`, color: "rgba(255,255,255,0.95)", sizeMul: 0.85 });
  if (multi > 0) lines.push({ txt: `+${multi} Multi`, color: "rgba(124,252,255,0.95)", sizeMul: 0.85 });
  lines.push({ txt: `+${comboBonus} Combo`, color: "rgba(183,255,106,0.95)", sizeMul: 0.85 });

  floatingTexts.push({
    lines,
    x, y,
    life: 1,
    vy: 1.25,
    size: 28,
    align: "center",
    stroke: "rgba(0,0,0,0.65)"
  });
}

function updateAndDrawFloatingTexts() {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y -= t.vy;
    t.life -= 0.02;

    const alpha = Math.max(0, t.life);
    if (alpha <= 0) { floatingTexts.splice(i, 1); continue; }

    let y = t.y;
    for (let j = 0; j < t.lines.length; j++) {
      const line = t.lines[j];
      const sz = t.size * (line.sizeMul ?? 1);
      ctx.save();
      ctx.globalAlpha = alpha;
      drawTextWithStroke(line.txt, t.x, y, sz, line.color, t.stroke, t.align);
      ctx.restore();
      y += sz * 1.05;
    }
  }
}

/** =========================
 *  計分規則（新）
 *  多線加成：每多一條 +16
 *  combo：25,45,65...
 *  ========================= */
function calcGain(lines, comboCount) {
  const base = lines * GRID_SIZE;
  const multiLineBonus = Math.max(0, lines - 1) * 16;
  const comboBonus = 25 + (comboCount - 1) * 20;
  const gain = base + multiLineBonus + comboBonus;
  return { base, multiLineBonus, comboBonus, gain };
}

/** =========================
 *  清除＆計分
 *  回傳：true=有消除、false=無消除
 *  （combo 中斷只在成功放置但無消除時發生）
 *  ========================= */
function checkAndClear() {
  const rs = [], cs = [];

  for (let r = 0; r < GRID_SIZE; r++) {
    if (grid[r].every(v => v === 1)) rs.push(r);
  }
  for (let c = 0; c < GRID_SIZE; c++) {
    let full = true;
    for (let r = 0; r < GRID_SIZE; r++) if (grid[r][c] === 0) full = false;
    if (full) cs.push(c);
  }

  const lines = rs.length + cs.length;
  if (lines <= 0) return false; // ✅ 沒消除：不動 combo

  // ✅ 有消除：combo++
  currentComboCount++;
  updateComboUI();

  // ✅ 計分
  const { base, multiLineBonus, comboBonus, gain } = calcGain(lines, currentComboCount);
  score += gain;

  document.getElementById('scoreDisplay').innerText = String(score);
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('blockHighScore', String(score));
    document.getElementById('highScore').innerText = String(score);
  }

  // 被清掉格子（做粒子）
  const clearedSet = new Set();
  for (const r of rs) for (let c = 0; c < GRID_SIZE; c++) clearedSet.add(`${r},${c}`);
  for (const c of cs) for (let r = 0; r < GRID_SIZE; r++) clearedSet.add(`${r},${c}`);
  const clearedCells = Array.from(clearedSet).map(s => {
    const [r, c] = s.split(',').map(Number);
    return { r, c };
  });

  // 特效
  spawnLineFlash(rs, cs);
  spawnClearParticles(clearedCells);
  shakeIntensity = Math.max(shakeIntensity, lines * 8);

  // breakdown 浮字
  const tier = getComboTier(currentComboCount);
  pushFloatingBreakdown(
    layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
    layout.gridY + (GRID_SIZE * CELL_SIZE) / 2 - 60,
    tier, base, multiLineBonus, comboBonus, gain
  );

  // 清掉
  rs.forEach(r => { for (let c = 0; c < GRID_SIZE; c++) grid[r][c] = 0; });
  cs.forEach(c => { for (let r = 0; r < GRID_SIZE; r++) grid[r][c] = 0; });

  return true;
}

/** =========================
 *  座標換算
 *  ========================= */
function getCanvasPosFromClient(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (canvas.width / (rect.width || 1));
  const y = (clientY - rect.top) * (canvas.height / (rect.height || 1));
  return { x, y };
}

/** =========================
 *  手牌命中 / home anchor
 *  ========================= */
function pickHandIndex(pos) {
  const { slots } = layout.hand;
  for (let i = 0; i < slots.length; i++) {
    const s = slots[i];
    if (pos.x >= s.x && pos.x <= s.x + s.w && pos.y >= s.y && pos.y <= s.y + s.h) {
      if (hand[i]) return i;
    }
  }
  return null;
}

function shapeBoundingBox(shape) {
  let minR = Infinity, minC = Infinity, maxR = -Infinity, maxC = -Infinity;
  for (const [r,c] of shape) {
    minR = Math.min(minR, r); minC = Math.min(minC, c);
    maxR = Math.max(maxR, r); maxC = Math.max(maxC, c);
  }
  return { minR, minC, maxR, maxC, w: maxC - minC + 1, h: maxR - minR + 1 };
}

// 回彈/拖曳起點：以 slot 置中，回傳「拖曳 anchor（左上角近似）」
function getHandSlotHomeAnchor(idx, shape) {
  const slot = layout.hand.slots[idx];
  const bb = shapeBoundingBox(shape);
  const block = layout.handBlock;
  const gap = layout.handGap;

  const shapeW = bb.w * (block + gap) - gap;
  const shapeH = bb.h * (block + gap) - gap;

  const startX = slot.x + (slot.w - shapeW) / 2;
  const startY = slot.y + (slot.h - shapeH) / 2;

  const anchorCenterX = startX + (0 - bb.minC) * (block + gap) + block / 2;
  const anchorCenterY = startY + (0 - bb.minR) * (block + gap) + block / 2;

  return {
    x: anchorCenterX - CELL_SIZE * 0.5,
    y: anchorCenterY - CELL_SIZE * 0.5
  };
}

/** =========================
 *  磁吸：以 anchor 找附近最近且可放置
 *  ========================= */
function findBestMagnet(shape, anchorX, anchorY) {
  const gx = (anchorX - layout.gridX) / CELL_SIZE;
  const gy = (anchorY - layout.gridY) / CELL_SIZE;

  const baseC = Math.round(gx);
  const baseR = Math.round(gy);

  let best = null;

  for (let dr = -MAGNET_SEARCH_RADIUS; dr <= MAGNET_SEARCH_RADIUS; dr++) {
    for (let dc = -MAGNET_SEARCH_RADIUS; dc <= MAGNET_SEARCH_RADIUS; dc++) {
      const r = baseR + dr;
      const c = baseC + dc;
      if (r < 0 || c < 0 || r >= GRID_SIZE || c >= GRID_SIZE) continue;
      if (!canPlace(shape, r, c)) continue;

      const snappedX = layout.gridX + c * CELL_SIZE;
      const snappedY = layout.gridY + r * CELL_SIZE;

      const dx = (anchorX - snappedX) / CELL_SIZE;
      const dy = (anchorY - snappedY) / CELL_SIZE;
      const distNorm = Math.hypot(dx, dy);

      if (best === null || distNorm < best.distNorm) {
        best = { r, c, snappedX, snappedY, distNorm };
      }
    }
  }

  if (!best) {
    const r = baseR, c = baseC;
    const snappedX = layout.gridX + c * CELL_SIZE;
    const snappedY = layout.gridY + r * CELL_SIZE;
    const dx = (anchorX - snappedX) / CELL_SIZE;
    const dy = (anchorY - snappedY) / CELL_SIZE;
    const distNorm = Math.hypot(dx, dy);
    return { r, c, snappedX, snappedY, distNorm, can: false };
  }
  return { ...best, can: true };
}

/** =========================
 *  失敗回饋：震動＋紅提示＋回彈（不影響 combo）
 *  ========================= */
function failFeedback() {
  shakeIntensity = Math.max(shakeIntensity, FAIL_SHAKE);
  failOverlayLife = 1;

  floatingTexts.push({
    lines: [{ txt: "放不下！", color: "#FF6A6A", sizeMul: 1.1 }],
    x: layout.gridX + (GRID_SIZE * CELL_SIZE) / 2,
    y: layout.gridY + (GRID_SIZE * CELL_SIZE) / 2 - 30,
    life: 1,
    vy: 1.1,
    size: 28,
    align: "center",
    stroke: "rgba(0,0,0,0.70)"
  });

  if (navigator.vibrate) {
    try { navigator.vibrate(FAIL_VIBRATION_PATTERN); } catch (_) {}
  }
}

function startBounceBack(idx, shape, fromAnchorX, fromAnchorY) {
  bounceLife = 1;
  bounceShape = shape;
  bounceTheme = currentTheme;

  bounceFromX = fromAnchorX;
  bounceFromY = fromAnchorY;

  const home = getHandSlotHomeAnchor(idx, shape);
  bounceToX = home.x;
  bounceToY = home.y;
}

/** =========================
 *  輸入（Pointer）
 *  ========================= */
function handlePointerDown(e) {
  if (gameOver) return;
  canvas.setPointerCapture?.(e.pointerId);

  const pos = getCanvasPosFromClient(e.clientX, e.clientY);
  pointerX = pos.x; pointerY = pos.y;

  const idx = pickHandIndex(pos);
  if (idx !== null) {
    draggingIdx = idx;

    dragStartPX = pointerX;
    dragStartPY = pointerY;

    const home = getHandSlotHomeAnchor(draggingIdx, hand[draggingIdx]);
    dragStartAX = home.x;
    dragStartAY = home.y;

    dragNowAX = dragStartAX;
    dragNowAY = dragStartAY;
  }
}

function handlePointerMove(e) {
  const events = (e.getCoalescedEvents && e.getCoalescedEvents()) || null;
  const last = events && events.length ? events[events.length - 1] : e;

  const pos = getCanvasPosFromClient(last.clientX, last.clientY);
  pointerX = pos.x; pointerY = pos.y;

  if (draggingIdx !== null) {
    const dx = (pointerX - dragStartPX) * DRAG_GAIN;
    const dy = (pointerY - dragStartPY) * DRAG_GAIN;
    dragNowAX = dragStartAX + dx;
    dragNowAY = dragStartAY + dy;
  }
}

function handlePointerUpOrCancel() {
  if (draggingIdx === null) return;

  const shape = hand[draggingIdx];
  if (shape) {
    const anchorX = dragNowAX;
    const anchorY = dragNowAY;

    const best = findBestMagnet(shape, anchorX, anchorY);

    // 放置：只要 best.can 就吸
    let r, c;
    if (best.can) {
      r = best.r; c = best.c;
    } else {
      r = Math.floor((anchorY - layout.gridY) / CELL_SIZE);
      c = Math.floor((anchorX - layout.gridX) / CELL_SIZE);
    }

    r = Math.max(0, Math.min(GRID_SIZE - 1, r));
    c = Math.max(0, Math.min(GRID_SIZE - 1, c));

    if (canPlace(shape, r, c)) {
      // ✅ 成功放上棋盤
      for (const coord of shape) grid[r + coord[0]][c + coord[1]] = 1;
      hand[draggingIdx] = null;

      // ✅ combo 只有在「成功放置但沒消除」才清
      const cleared = checkAndClear();
      if (!cleared) {
        currentComboCount = 0;
        updateComboUI();
      }

      if (hand.every(h => h === null)) refreshHand();

      // 死局判斷
      let dead = true;
      for (const s of hand) {
        if (!s) continue;
        for (let i = 0; i < GRID_SIZE; i++) {
          for (let j = 0; j < GRID_SIZE; j++) {
            if (canPlace(s, i, j)) { dead = false; break; }
          }
          if (!dead) break;
        }
        if (!dead) break;
      }
      if (dead) gameOver = true;

    } else {
      // ❌ 放置失敗：不影響 combo，只回饋＋回彈
      failFeedback();
      startBounceBack(draggingIdx, shape, anchorX, anchorY);
    }
  }

  draggingIdx = null;
}

canvas.addEventListener('pointerdown', handlePointerDown);
window.addEventListener('pointermove', handlePointerMove);
window.addEventListener('pointerup', handlePointerUpOrCancel);
window.addEventListener('pointercancel', handlePointerUpOrCancel);
window.addEventListener('pointerrawupdate', handlePointerMove);

/** =========================
 *  繪製：手牌
 *  ========================= */
function drawHand() {
  const { slots } = layout.hand;

  if (layout.mode === "mobile") {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(layout.hand.x, layout.hand.y, layout.hand.w, layout.hand.h);
    ctx.restore();
  }

  for (let i = 0; i < 3; i++) {
    const shape = hand[i];
    const slot = slots[i];

    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 2;
    pathRoundedRect(slot.x + 6, slot.y + 6, slot.w - 12, slot.h - 12, 14);
    ctx.stroke();
    ctx.restore();

    if (!shape || i === draggingIdx) continue;

    const bb = shapeBoundingBox(shape);
    const block = layout.handBlock;
    const gap = layout.handGap;

    const shapeW = bb.w * (block + gap) - gap;
    const shapeH = bb.h * (block + gap) - gap;

    const startX = slot.x + (slot.w - shapeW) / 2;
    const startY = slot.y + (slot.h - shapeH) / 2;

    for (const coord of shape) {
      const x = startX + (coord[1] - bb.minC) * (block + gap);
      const y = startY + (coord[0] - bb.minR) * (block + gap);
      drawBlock(x, y, block, 6, currentTheme, 1);
    }
  }
}

/** =========================
 *  回彈動畫
 *  ========================= */
function updateAndDrawBounce() {
  if (bounceLife <= 0 || !bounceShape || !bounceTheme) return;

  const t = 1 - bounceLife;
  const c1 = 1.70158;
  const c3 = c1 + 1;
  const easeOutBack = (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
  const k = easeOutBack(Math.min(1, Math.max(0, t)));

  const ax = bounceFromX + (bounceToX - bounceFromX) * k;
  const ay = bounceFromY + (bounceToY - bounceFromY) * k;

  const scale = 0.96 + 0.06 * (1 - Math.abs(0.5 - t) * 2);

  ctx.save();
  ctx.globalAlpha = 0.9 * bounceLife;

  for (const coord of bounceShape) {
    const x = ax + coord[1] * CELL_SIZE;
    const y = (ay - DRAG_LIFT * 0.45) + coord[0] * CELL_SIZE;
    const sx = x + (CELL_SIZE - 4) * (1 - scale) * 0.5;
    const sy = y + (CELL_SIZE - 4) * (1 - scale) * 0.5;
    drawBlock(sx, sy, (CELL_SIZE - 4) * scale, 8, bounceTheme, ctx.globalAlpha);
  }

  ctx.restore();

  bounceLife -= 0.06;
  if (bounceLife <= 0) {
    bounceLife = 0;
    bounceShape = null;
  }
}

/** =========================
 *  animate
 *  ========================= */
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();

  // 抖動
  if (shakeIntensity > 0) {
    ctx.translate((Math.random() - 0.5) * shakeIntensity, (Math.random() - 0.5) * shakeIntensity);
    shakeIntensity *= 0.8;
    if (shakeIntensity < 0.3) shakeIntensity = 0;
  }

  // 棋盤背景
  ctx.fillStyle = '#333';
  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
      const x = layout.gridX + c * CELL_SIZE + 2;
      const y = layout.gridY + r * CELL_SIZE + 2;
      ctx.fillRect(x, y, CELL_SIZE - 4, CELL_SIZE - 4);
    }
  }

  if (currentTheme) {
    // 固定方塊
    for (let r = 0; r < GRID_SIZE; r++) {
      for (let c = 0; c < GRID_SIZE; c++) {
        if (grid[r][c]) {
          const x = layout.gridX + c * CELL_SIZE + 2;
          const y = layout.gridY + r * CELL_SIZE + 2;
          drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, 1);
        }
      }
    }

    // 清除閃光
    updateAndDrawLineFlashes();

    // 拖曳顯示
    if (draggingIdx !== null && hand[draggingIdx]) {
      const shape = hand[draggingIdx];
      const anchorX = dragNowAX;
      const anchorY = dragNowAY;

      // 預覽（只要附近有可放就吸那格）
      const best = findBestMagnet(shape, anchorX, anchorY);
      let previewR, previewC;
      if (best.can) { previewR = best.r; previewC = best.c; }
      else {
        previewR = Math.floor((anchorY - layout.gridY) / CELL_SIZE);
        previewC = Math.floor((anchorX - layout.gridX) / CELL_SIZE);
      }

      if (canPlace(shape, previewR, previewC)) {
        for (const coord of shape) {
          const x = layout.gridX + (previewC + coord[1]) * CELL_SIZE + 2;
          const y = layout.gridY + (previewR + coord[0]) * CELL_SIZE + 2;
          drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, PREVIEW_ALPHA_OK);
        }
      } else {
        ctx.save();
        ctx.globalAlpha = PREVIEW_ALPHA_BAD;
        ctx.fillStyle = "rgba(255,80,80,1)";
        ctx.fillRect(layout.gridX, layout.gridY, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
        ctx.restore();
      }

      // 本體（上抬）
      const drawX = anchorX;
      const drawY = anchorY - DRAG_LIFT;
      for (const coord of shape) {
        const x = drawX + coord[1] * CELL_SIZE;
        const y = drawY + coord[0] * CELL_SIZE;
        drawBlock(x, y, CELL_SIZE - 4, 8, currentTheme, 1);
      }
    }

    // 手牌
    drawHand();

    // 粒子
    updateAndDrawParticles();

    // 回彈
    updateAndDrawBounce();

    // 浮字
    updateAndDrawFloatingTexts();
  }

  // 失敗紅提示 overlay
  if (failOverlayLife > 0) {
    ctx.save();
    ctx.globalAlpha = 0.35 * failOverlayLife;
    ctx.fillStyle = "rgba(255, 60, 60, 1)";
    ctx.fillRect(layout.gridX, layout.gridY, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
    ctx.restore();
    failOverlayLife -= 0.06;
    if (failOverlayLife < 0) failOverlayLife = 0;
  }

  // GAME OVER
  if (gameOver) {
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white";
    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
    restartBtn.style.display = "block";
  }

  ctx.restore();
  requestAnimationFrame(animate);
}

/** =========================
 *  resize：切換布局（不重置遊戲）
 *  ========================= */
function handleResize() {
  const prevMode = layout?.mode;
  const newLayout = computeLayout();
  if (!layout || prevMode !== newLayout.mode) applyLayout(newLayout);
  else applyLayout(newLayout);
}
window.addEventListener('resize', handleResize);

/** =========================
 *  啟動
 *  ========================= */
resetGame();
animate();
</script>

</body>
</html>
